<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咖啡加了安眠药</title>
  
  
  <link href="https://coffepill.top/atom.xml" rel="self"/>
  
  <link href="https://coffepill.top/"/>
  <updated>2022-09-28T15:17:38.017Z</updated>
  <id>https://coffepill.top/</id>
  
  <author>
    <name>coffepill</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>node.js学习笔记</title>
    <link href="https://coffepill.top/post/3c2bd137.html"/>
    <id>https://coffepill.top/post/3c2bd137.html</id>
    <published>2022-09-21T08:49:20.000Z</published>
    <updated>2022-09-28T15:17:38.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fs-文件系统模块"><a href="#fs-文件系统模块" class="headerlink" title="fs 文件系统模块"></a>fs 文件系统模块</h2><p>fs 模块是用来操作文件的模块</p><p>js代码中导入使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="fs方法"><a href="#fs方法" class="headerlink" title="fs方法"></a>fs方法</h3><h4 id="读取指定文件内容fs-readFile"><a href="#读取指定文件内容fs-readFile" class="headerlink" title="读取指定文件内容fs.readFile()"></a>读取指定文件内容fs.readFile()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(path[,options],callback)<span class="comment">//异步读取</span></span><br></pre></td></tr></table></figure><p>path:文件路径</p><p>第二个参数可选，如：“utf8”以utf-8编码格式显示，默认为utf</p><p>callback：回调函数，默认包含<code>err</code>(读取失败的内容,读取成功为null),<code>dataStr</code>(读取到的内容,读取失败为undefine)两个参数，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data=fs.<span class="title function_">readFileSync</span>(path[,options])<span class="comment">//同步读取文件，可直接返回读取到的内容</span></span><br></pre></td></tr></table></figure><h4 id="向指定文件写入内容fs-writeFile"><a href="#向指定文件写入内容fs-writeFile" class="headerlink" title="向指定文件写入内容fs.writeFile()"></a>向指定文件写入内容fs.writeFile()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFile</span>(path,data[,options],callback)</span><br></pre></td></tr></table></figure><p>data:写入内容</p><p>callback:回调函数，默认参数err(写入成功返回null)</p><blockquote><p>该方法写入会覆盖被写入文件原本内容，如果没有该文件则会新建文件写入</p></blockquote><h4 id="path参数相对路径问题（-dirname）"><a href="#path参数相对路径问题（-dirname）" class="headerlink" title="path参数相对路径问题（__dirname）"></a>path参数相对路径问题（__dirname）</h4><p>运行路径不在要运行的js文件父目录上时会导致读入操作路径拼接失败，可以改为用<code>__dirname</code>再接对应要读取的文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(__dirname+<span class="string">&quot;/js/2.js&quot;</span>,<span class="string">&quot;utf8&quot;</span>,<span class="keyword">function</span>(<span class="params">err,dataStr</span>)&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="path路径模块"><a href="#path路径模块" class="headerlink" title="path路径模块"></a>path路径模块</h2><p>用来处理路径的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="路径拼接path-join-…paths"><a href="#路径拼接path-join-…paths" class="headerlink" title="路径拼接path.join([…paths])"></a>路径拼接path.join([…paths])</h3><p><code>&quot;../&quot;</code>会抵消一层路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathstr=path.<span class="title function_">join</span>(<span class="string">&#x27;/a/b&#x27;</span>,<span class="string">&#x27;../&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathstr)<span class="comment">//\a</span></span><br></pre></td></tr></table></figure><blockquote><p>在调用fs时参数path最好通过path.join()进行拼接</p></blockquote><h3 id="获取路径中文件名path-basename"><a href="#获取路径中文件名path-basename" class="headerlink" title="获取路径中文件名path.basename()"></a>获取路径中文件名path.basename()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathname=path.<span class="title function_">basename</span>(fpath,<span class="string">&quot;.html&quot;</span>)<span class="comment">//第一个参数为文件路径，第二个参数可选，用于去除后缀</span></span><br></pre></td></tr></table></figure><h3 id="获取文件后缀名path-extname"><a href="#获取文件后缀名path-extname" class="headerlink" title="获取文件后缀名path.extname()"></a>获取文件后缀名path.extname()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathExtname=path.<span class="title function_">extname</span>(fpath)<span class="comment">//输出&quot;.html&quot;</span></span><br></pre></td></tr></table></figure><h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><p>用来搭建web服务器的模块</p><p>导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="title function_">request</span>(<span class="string">&quot;http&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="创建web服务器实例"><a href="#创建web服务器实例" class="headerlink" title="创建web服务器实例"></a>创建web服务器实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> serve=http.<span class="title function_">craeteServer</span>()</span><br></pre></td></tr></table></figure><h3 id="为服务器绑定request事件"><a href="#为服务器绑定request事件" class="headerlink" title="为服务器绑定request事件"></a>为服务器绑定request事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Someone visit our web server&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="req请求对象"><a href="#req请求对象" class="headerlink" title="req请求对象"></a>req请求对象</h4><p>它包含了与客户端相关的数据和属性，如：</p><p>req.url是客户端请求的URL地址</p><p>req.method是客户端的method请求类型</p><h3 id="res响应对象"><a href="#res响应对象" class="headerlink" title="res响应对象"></a>res响应对象</h3><p>res.end(str)可向客户端发送响应内容；</p><p>str的内容如果是中文会变成乱码，这时候就需要加入请求头<code>res.setHeader()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>Content-Type</code> 请求头的类型，一般情况有以下四种类型</p><p><code>text/html</code>表示提交xml类型的数据<code>&lt;name&gt;张三&lt;/name&gt;</code></p><p><code>application/x-www-form-urlencoded</code>表示常见的form表单提交&#x2F;web提交</p><p><code>application/json</code>表示提交json格式的数据mulltipart&#x2F;form-data表示文件提交</p></blockquote><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//server.listen(端口号，cb回调)</span><br><span class="line">server.listen(80,()=&gt;&#123;</span><br><span class="line">console.log(&quot;welcome!&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。</p><h3 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h3><p>内置模块，自定义模块，第三方模块</p><h3 id="moudle对象"><a href="#moudle对象" class="headerlink" title="moudle对象"></a>moudle对象</h3><p>每个自定义.js文件中都默认存在moudle对象</p><p>其他文件要访问自定义moudle时需要通过exports属性对象访问，node.js也有封装exports对象用于将moudle内容导出</p><blockquote><p>如果同时用moudle.exports和exports,则moudle.exports优先级更高</p></blockquote><h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p>node.js遵循CommonJS模块化规范，CommonJS规定了<code>模块的特性</code>和<code>模块之间如何相互依赖</code>。</p><p>规定：</p><ul><li>每个模块内部，moudle变量代表当前模块</li><li>moudle变量是一个对象，它的exports属性是对外的接口</li><li>加载某个模块，其实是加载该模块的moudle.exports属性。</li></ul><h2 id="npm与包"><a href="#npm与包" class="headerlink" title="npm与包"></a>npm与包</h2><p>包即第三方组件，npm即是node.js自带的包管理工具。</p><h3 id="包的语义化版本规范"><a href="#包的语义化版本规范" class="headerlink" title="包的语义化版本规范"></a>包的语义化版本规范</h3><p>一般为<code>数字.数字.数字</code>第一个为大版本，第二个为功能版本，第三个为bug修复版本，前一个数字更新后一个数字就会归零</p><h3 id="包分类"><a href="#包分类" class="headerlink" title="包分类"></a>包分类</h3><p>项目包（开发依赖包，核心依赖包）；全局包，安装时添加-g参数  </p><h3 id="package-json创建"><a href="#package-json创建" class="headerlink" title="package.json创建"></a>package.json创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><h3 id="包的结构规范"><a href="#包的结构规范" class="headerlink" title="包的结构规范"></a>包的结构规范</h3><ul><li>一个包必须以单独的目录存在</li><li>在包的顶级目录下必须包含package.json这个包管理配置文件</li><li>package.json中必须包含name，version,main这三个属性，分别代表包的名字，版本号，包的入口</li></ul><h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><h4 id="优先从缓存中加载"><a href="#优先从缓存中加载" class="headerlink" title="优先从缓存中加载"></a>优先从缓存中加载</h4><p>模块在第一次加载后会被缓存，多次调用require不会导致模块的代码多次被执行</p><h4 id="内置模块的加载机制"><a href="#内置模块的加载机制" class="headerlink" title="内置模块的加载机制"></a>内置模块的加载机制</h4><p>由Node.js官方提供的模块，内置模块的加载优先级最高，优先于其他模块被加载</p><h4 id="自定义模块的加载机制"><a href="#自定义模块的加载机制" class="headerlink" title="自定义模块的加载机制"></a>自定义模块的加载机制</h4><p>require(path)省略文件拓展名，则Node.js按一下顺序加载文件</p><ol><li>按照确切的文件名加载</li><li>补全.js扩展名加载</li><li>补全.json扩展名加载</li><li>补全.node扩展名进行加载</li><li>加载失败，终端报错</li></ol><h4 id="第三方模块加载机制"><a href="#第三方模块加载机制" class="headerlink" title="第三方模块加载机制"></a>第三方模块加载机制</h4><p>如果require()的模块标识符不是内置模块，也没有“..&#x2F;”或“.&#x2F;”开头，则Node会从当前模块的父目录开始，尝试从&#x2F;node_moudles文件夹中加载第三方模块，如果没有就会到上一层父目录中继续寻找直到系统根目录</p><h4 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h4><p>当把目录作为模块标识符，传递给require()进行加载时，有三种加载方式：</p><p>在被加载的目录下查找package.json的文件，并寻找main属性，作为加载入口</p><p>如果没有package.json或者没有main属性则会试图加载目录下的index.js文件</p><p>如果都失败则会报错</p><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>基于Node.js平台，开苏开放极简框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express -save</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="comment">//启动web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,()=&#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="监听GET请求"><a href="#监听GET请求" class="headerlink" title="监听GET请求"></a>监听GET请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(url,<span class="keyword">function</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">    <span class="comment">//res.send()用于响应请求</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123;<span class="attr">age</span>:<span class="number">10</span>,<span class="attr">name</span>:<span class="string">&quot;As&quot;</span>&#125;)</span><br><span class="line">    <span class="comment">//req.query用于获取客户端发送的查询参数即‘?’后的参数</span></span><br><span class="line">    <span class="comment">//req.params获取url中的动态参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="监听POST请求"><a href="#监听POST请求" class="headerlink" title="监听POST请求"></a>监听POST请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(url,<span class="keyword">function</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">    <span class="comment">//req.res的属性同GET</span></span><br><span class="line">    <span class="comment">//req.body 获取请求数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="托管静态资源express-static"><a href="#托管静态资源express-static" class="headerlink" title="托管静态资源express.static()"></a>托管静态资源express.static()</h3><p>用于快速的对外提供静态资源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.use(express.static(&#x27;./1&#x27;))</span></span><br><span class="line"><span class="comment">//挂载访问前缀</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&quot;/pubilc&quot;</span>,express.<span class="title function_">static</span>(<span class="string">&#x27;./1&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="自动重启修改的项目"><a href="#自动重启修改的项目" class="headerlink" title="自动重启修改的项目"></a>自动重启修改的项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g nodemon</span><br></pre></td></tr></table></figure><p>之后启用node命令 改为使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon 1.js</span><br></pre></td></tr></table></figure><h3 id="express路由"><a href="#express路由" class="headerlink" title="express路由"></a>express路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">METHOD</span>(<span class="variable constant_">PATH</span>,<span class="variable constant_">HANDLER</span>)<span class="comment">//请求类型，请求的URL地址，处理函数</span></span><br></pre></td></tr></table></figure><h4 id="路由匹配过程"><a href="#路由匹配过程" class="headerlink" title="路由匹配过程"></a>路由匹配过程</h4><p>按照定义的先后顺序进行匹配</p><p>请求类型和请求的URL同时匹配成功，才会调用对应的处理函数</p><h3 id="路由模块化"><a href="#路由模块化" class="headerlink" title="路由模块化"></a>路由模块化</h3><ul><li>创建路由模块对应的js文件</li><li>调用express.Router()函数创建路由对象</li><li>向路由对象上挂载具体的路由</li><li>使用moudle.exports向外共享路由对象</li><li>使用app.use()函数注册路由模块</li></ul><blockquote><p>app的作用就是注册全局中间件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&quot;/api&quot;</span>,route)<span class="comment">//可以添加默认的前缀路径</span></span><br></pre></td></tr></table></figure><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>就是对请求进行预处理</p><p>本质上就是一个function处理函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>,<span class="keyword">function</span>(<span class="params">req,res,next</span>)&#123;<span class="title function_">next</span>()&#125;)<span class="comment">//有next()函数的为中间件</span></span><br></pre></td></tr></table></figure><p>可以自定义中间件，之后通过app.use()进行注册</p><h4 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h4><p>中间件会共享req,res，可以通过添加req,res属性来传递共享数据</p><h3 id="多个全局中间件"><a href="#多个全局中间件" class="headerlink" title="多个全局中间件"></a>多个全局中间件</h3><p> 多次声明app.use()注册即可</p><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>,<span class="string">&#x27;中间件1&#x27;</span>,<span class="string">&#x27;中间件1&#x27;</span>,<span class="keyword">function</span>(<span class="params">req,res</span>)&#123;&#125;)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>,[<span class="string">&#x27;中间件1&#x27;</span>,<span class="string">&#x27;中间件1&#x27;</span>],<span class="keyword">function</span>(<span class="params">req,res</span>)&#123;&#125;)<span class="comment">//两种写法都可</span></span><br></pre></td></tr></table></figure><div class="note warning simple"><ol><li>一定要在路由之前注册中间件</li><li>客户端发送的请求可以连续多个中间件处理</li><li>不要忘记调用next()函数</li><li>为了防止代码逻辑混乱，调用next()函数不要再写额外的代码</li><li>连续调用多个中间件时，多个中间件之间共享req和res对象</li></ol></div><h3 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h3><p>1.全局中间件</p><p>2.局部中间件，通过router.use()注册</p><p>3.错误中间件</p><pre><code>作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题格式：</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;服务器内部异常！&quot;</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//错误中间件要放在所有路由之后 </span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">err,req,res,next</span>)&#123; </span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">&quot;Error!&quot;</span>+err.<span class="property">message</span>) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="express内置中间件"><a href="#express内置中间件" class="headerlink" title="express内置中间件"></a>express内置中间件</h3><p><code>express.static</code>快速托管静态资源内置中间件（无兼容性问题）</p><p><code>express.json</code>解析JSON格式的请求体数据（有兼容性）</p><p><code>express.urlencoded</code>解析URL-encoded格式的请求体数据（有兼容性，4.16.0+版本可用）</p><h3 id="中间件中req对数据量大的请求处理"><a href="#中间件中req对数据量大的请求处理" class="headerlink" title="中间件中req对数据量大的请求处理"></a>中间件中req对数据量大的请求处理</h3><p>1.用req 的data事件去拼接被拆解的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">chunk</span>)=&gt;</span>&#123;</span><br><span class="line">str+=chunk;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.用req的end事件监听是否接收完毕</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="接口跨域问题"><a href="#接口跨域问题" class="headerlink" title="接口跨域问题"></a>接口跨域问题</h2><h3 id="cors跨域资源共享"><a href="#cors跨域资源共享" class="headerlink" title="cors跨域资源共享"></a>cors跨域资源共享</h3><p>CORS是一系列http响应头组成，这些http响应头决定浏览器是否阻止前端js代码跨域获取资源，兼容性（IE10+，Chorme4+,FireFox3.5+）</p><blockquote><p>一定要在路由之前，调用cors中间件</p></blockquote><p>使用：</p><p>1.运行 <code>npm install cors</code> 安装中间件</p><p>2.引入 <code>const cors=require(&#39;cors&#39;)</code></p><p>3.在路由之前调用 <code>app.use(cors())</code> 配置中间件</p><h4 id="CORS响应头部"><a href="#CORS响应头部" class="headerlink" title="CORS响应头部"></a>CORS响应头部</h4><p><strong>Access-Control-Allow-Origin</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&quot;*&quot;)//允许任何域访问，</span><br></pre></td></tr></table></figure><p><strong>Access-Control-Allow-Headers</strong></p><p>如果客户端向服务器发送额外的请求头信息，则需要在服务端通过Access-Control-Allow-Headers对额外请求头进行声明</p><p><strong>Access-Control-Allow-Methods</strong></p><p>默认情况下，CORS仅支持GET，POST,HEAD请求，如要以其他方式发送请求就需要用Access-Control-Allow-Methods来指明实际请求允许使用的http方法</p><h4 id="简单请求-x2F-预检请求"><a href="#简单请求-x2F-预检请求" class="headerlink" title="简单请求&#x2F;预检请求"></a>简单请求&#x2F;预检请求</h4><p>不需要设置额外请求头和额外请求方法的请求即为简单请求</p><p>请求方式在get,post,head之外，请求头自定义头部字段，向服务器发送application&#x2F;json格式数据满足条件之一都需要进行预检请求</p><p>预检请求在浏览器与服务器通信之前都需要先发送OPTION请求进行预检，以获取服务器是否允许实际请求，而这OPTION请求就是预检请求</p><h3 id="JSONP接口"><a href="#JSONP接口" class="headerlink" title="JSONP接口"></a>JSONP接口</h3><p>浏览器通过<code>&lt;script&gt;</code>标签的src属性，请求服务器上的数据，同时服务器返回一个函数的调用。这种请求数据的方式叫做jsonp。</p><p>jsonp必须在配置cors之前，使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;api/jsonp&#x27;</span>,<span class="function">(<span class="params">req.res</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//1.得到函数名称</span></span><br><span class="line">    <span class="keyword">const</span> functionName=req.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">    <span class="comment">//2.定义要发送的数据对象</span></span><br><span class="line">    <span class="keyword">const</span> data=&#123;<span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;</span><br><span class="line">    <span class="comment">//3.拼接出函数调用</span></span><br><span class="line">    <span class="keyword">const</span> scriptStr=<span class="string">`<span class="subst">$&#123;functionName&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span></span><br><span class="line">    res.<span class="title function_">send</span>(scriptStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接口调用：</p><p>在请求中要申明<code>dataType:&#39;jsonp&#39;</code></p><h2 id="mysql模块"><a href="#mysql模块" class="headerlink" title="mysql模块"></a>mysql模块</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入</span></span><br><span class="line"><span class="keyword">const</span> mysql=<span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line"><span class="keyword">const</span> db=mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>:<span class="string">&quot;127.0.0.1&quot;</span>,<span class="comment">//数据库IP地址</span></span><br><span class="line">    <span class="attr">user</span>:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>:<span class="string">&#x27;admin123&#x27;</span></span><br><span class="line">    <span class="attr">database</span>:<span class="string">&#x27;my_db&#x27;</span> <span class="comment">//指定操作的数据库</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="查找-x2F-插入-x2F-更新-x2F-删除"><a href="#查找-x2F-插入-x2F-更新-x2F-删除" class="headerlink" title="查找&#x2F;插入&#x2F;更新&#x2F;删除"></a>查找&#x2F;插入&#x2F;更新&#x2F;删除</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str=<span class="string">&quot;查询语句&quot;</span></span><br><span class="line">db.<span class="title function_">query</span>(str,<span class="function">(<span class="params">err,result</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user=&#123;<span class="attr">username</span>:<span class="string">&quot;11&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;22&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> str=<span class="string">&quot;INSERT INTO users (username,password) VALUES (?,?)&quot;</span></span><br><span class="line">db.<span class="title function_">query</span>(str,[user.<span class="property">username</span>,user.<span class="property">password</span>],<span class="function">(<span class="params">err,result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.<span class="property">affectedRows</span>===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>更新，删除与插入类似</p><h2 id="web开发模式"><a href="#web开发模式" class="headerlink" title="web开发模式"></a>web开发模式</h2><p>服务器端渲染的Web开发模式：</p><p>服务器向客户端发送的HTML页面，是服务器通过字符串的拼接，动态生成的，客户端不需要通过Ajax额外获取页面数据</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>前端耗时少，有利于SEO</p><p>占用服务器资源，不利于前后端分离，开发效率低</p><h3 id="cookie特性"><a href="#cookie特性" class="headerlink" title="cookie特性"></a>cookie特性</h3><p>过期时限；自动发送；域名独立；4KB限制；</p><blockquote><p>expires:过期日期时间</p><p>damin和path:域名和路径构成URL</p><p>secure:true或false,设置为true时只有在保证安全的情况下才会发送，如https协议下</p><p>httpOnly:是否禁止js访问，只能在服务端设置</p><p>一般需要跨域请求才能使用</p></blockquote><h3 id="Session认证"><a href="#Session认证" class="headerlink" title="Session认证"></a>Session认证</h3><p>配置express-session中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> session=<span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>:<span class="string">&#x27;key&#x27;</span>,<span class="comment">//可以是任意字符</span></span><br><span class="line">    <span class="attr">resave</span>:<span class="literal">false</span>,<span class="comment">//固定写法</span></span><br><span class="line">    <span class="attr">saveUninitialized</span>:<span class="literal">true</span><span class="comment">//固定写法</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="JWT认证机制"><a href="#JWT认证机制" class="headerlink" title="JWT认证机制"></a>JWT认证机制</h3><p>由Header，Payload，Signature组成，用<code>.</code>间隔开，Payload才是真正的用户信息</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>通常存储在webStorage中，在发送请求时，将JWT放在HTTP请求头的Authorization字段中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><p>在Express中使用JWT</p><p>1.安装相关的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install jsonwebtoken express-jwt</span><br><span class="line">//jsonwebtoken用于生成token</span><br><span class="line">//express-jwt用于将JWT字符串解析成JSON对象</span><br></pre></td></tr></table></figure><p>2.导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonwebtoken=<span class="built_in">require</span>(<span class="string">&quot;jsonwebtoken&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> express_jwt=<span class="built_in">require</span>(<span class="string">&quot;express-jwt&quot;</span>)</span><br></pre></td></tr></table></figure><p>3.定义secret密钥</p><p>为了JWT字符串的安全性，防止JWT字符串在网络传输过程中被别人破解，需要专门定义一个用于加密和解密的secret密钥，secert可以是任意字符</p><p>4.在登录成功后生成JWT字符串</p><p>调用jsonwebtoken的sign()方法，将用户信息加密并返回给客户端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">send</span>(&#123;</span><br><span class="line"><span class="attr">status</span>:<span class="number">200</span>,</span><br><span class="line">    <span class="attr">message</span>:<span class="string">&quot;登录成功！&quot;</span>，</span><br><span class="line">    <span class="comment">//三个参数，用户对象信息，加密密钥，配置对象</span></span><br><span class="line">    <span class="attr">token</span>:jwt.<span class="title function_">sign</span>(&#123;<span class="attr">username</span>:userinfo.<span class="property">username</span>&#125;,secretKey,&#123;<span class="attr">expiresIn</span>:<span class="string">&#x27;30s&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>5.将JWT还原为JSON</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">express_jwt</span>(&#123;<span class="attr">secret</span>:secretKey&#125;).<span class="title function_">unless</span>(&#123;<span class="attr">path</span>:[<span class="regexp">/^\/api\//</span>] &#125;))</span><br><span class="line"><span class="comment">//unless可以设置哪些路由不用访问权限</span></span><br></pre></td></tr></table></figure><p>6.使用req.auth&#x2F;req.user获取用户信息</p><p>只要配置成功express-jwt中间件，就可以把解析出来的用户信息挂载到req.auth&#x2F;req.user中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;fs-文件系统模块&quot;&gt;&lt;a href=&quot;#fs-文件系统模块&quot; class=&quot;headerlink&quot; title=&quot;fs 文件系统模块&quot;&gt;&lt;/a&gt;fs 文件系统模块&lt;/h2&gt;&lt;p&gt;fs 模块是用来操作文件的模块&lt;/p&gt;
&lt;p&gt;js代码中导入使用：&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="https://coffepill.top/post/c783f2ce.html"/>
    <id>https://coffepill.top/post/c783f2ce.html</id>
    <published>2022-09-12T09:04:37.000Z</published>
    <updated>2022-09-30T06:57:48.281Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>暂时还没整理</p></blockquote><h3 id="结构化分析方法所使用的工具"><a href="#结构化分析方法所使用的工具" class="headerlink" title="结构化分析方法所使用的工具"></a>结构化分析方法所使用的工具</h3><p>结构化分析方法给出一组帮助<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90">系统分析</a>人员产生功能规约的原理与技术。它一般利用图形表达用户需求，使用的手段主要有<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE">数据流图</a>、<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8">数据字典</a>、<a href="https://baike.baidu.com/item/%E7%BB%93%E6%9E%84%E5%8C%96%E8%AF%AD%E8%A8%80">结构化语言</a>、<a href="https://baike.baidu.com/item/%E5%88%A4%E5%AE%9A%E8%A1%A8">判定表</a>以及<a href="https://baike.baidu.com/item/%E5%88%A4%E5%AE%9A%E6%A0%91/10787830">判定树</a>等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;暂时还没整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;结构化分析方法所使用的工具&quot;&gt;&lt;a href=&quot;#结构化分析方法所使用的工具&quot; class=&quot;headerlink&quot; title=&quot;结构化分析方法所使用的工具&quot;&gt;&lt;/a&gt;结构化分析方</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端面试知识整理（待更新）</title>
    <link href="https://coffepill.top/post/bd261a9c.html"/>
    <id>https://coffepill.top/post/bd261a9c.html</id>
    <published>2022-08-09T16:52:34.000Z</published>
    <updated>2022-09-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="行内元素-x2F-块级元素"><a href="#行内元素-x2F-块级元素" class="headerlink" title="行内元素&#x2F;块级元素"></a>行内元素&#x2F;块级元素</h3><h3 id="link与-import"><a href="#link与-import" class="headerlink" title="link与@import"></a>link与@import</h3><p>1.<code>link</code>比<code>@import</code>兼容性更好，@import出现于css2.1对老版本的浏览器兼容性较差</p><p>2.加载顺序,<code>link</code>会在加载页面时同时加载，<code>@import</code>在页面加载完成后才加载</p><p>3.<code>link</code>属于html标签，<code>@import</code>属于css标签，加载方式不同</p><p>4.<code>link</code>可以通过操作dom修改样式</p><h3 id="title与h1的区别，b与strong的区别，i与em的区别"><a href="#title与h1的区别，b与strong的区别，i与em的区别" class="headerlink" title="title与h1的区别，b与strong的区别，i与em的区别"></a>title与h1的区别，b与strong的区别，i与em的区别</h3><div class="tabs" id="标签区别"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#标签区别-1">title/h1</button></li><li class="tab"><button type="button" data-href="#标签区别-2">b/strong</button></li><li class="tab"><button type="button" data-href="#标签区别-3">i/em</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="标签区别-1"><ul><li><code>title</code>为网页标题，用于网站搜索优化时使用</li><li><code>h1</code>为内容标题</li><li><code>title</code>比<code>h1</code>的添加重要，影响<strong>SEO</strong></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="标签区别-2"><ul><li><code>b</code>实体标签，用来给文字加粗</li><li><code>strong</code>逻辑标签，用来加强字符语气</li><li><code>b</code>没有实际含义，<code>strong</code>表示强调</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="标签区别-3"><ul><li><code>i</code>实体标签，用来做文字倾斜</li><li><code>em</code>逻辑标签，用来加强字符语气</li><li><code>i</code>没有实际含义，<code>em</code>表示强调</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>强调文本是为了该标签中的内容在搜索引擎中更受重视,一些语音阅读器也会根据它在阅读时加强语气</p></blockquote><h3 id="img的title与alt"><a href="#img的title与alt" class="headerlink" title="img的title与alt"></a>img的title与alt</h3><ul><li><code>titile</code>鼠标移入到图片显示的值</li><li><code>alt</code>图片无法加载时显示的值</li><li>在优化seo时需要在alt加入内容利于蜘蛛捕获</li></ul><h3 id="png、jpg、gif区别"><a href="#png、jpg、gif区别" class="headerlink" title="png、jpg、gif区别"></a>png、jpg、gif区别</h3><ol><li><code>png</code>无损压缩，尺寸体积大于jpg,适合做小图标</li><li><code>jpg</code>采用压缩算法，用于中大图片</li><li><code>gif</code>动图</li><li><code>webp</code>同时支持有损或无损压缩，相同质量的图片<code>webp</code>体积更小，兼容性差</li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h3><p><strong>1.CSS3选择器</strong></p><p><strong>2.CSS3边框与圆角</strong></p><p><strong>3.CSS3背景与渐变</strong></p><p><strong>4.CSS3过渡</strong></p><p><strong>5.CSS3变换</strong></p><p><strong>6.CSS3动画</strong></p><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><div class="tabs" id="盒子模型"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#盒子模型-1">标准盒子</button></li><li class="tab"><button type="button" data-href="#盒子模型-2">IE盒子</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="盒子模型-1"><pre><code>`box-sizing:content-box;`(元素默认)</code></pre><ul><li>margin-border-padding-content</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="盒子模型-2"><pre><code>`box-sizing:border-box;`(也叫怪异盒子模型)</code></pre><ul><li>margin-content(border+padding+content),元素宽高等于<code>content</code>大小，如果内容padding超过宽高，则border会变成在盒子外</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="line-height和height区别"><a href="#line-height和height区别" class="headerlink" title="line-height和height区别"></a>line-height和height区别</h3><ul><li><code>line-height</code>是一行文字的高，如果文字内容高度高于<code>height</code>,会自动撑高</li></ul><h3 id="css选择器，可继承属性"><a href="#css选择器，可继承属性" class="headerlink" title="css选择器，可继承属性"></a>css选择器，可继承属性</h3><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">css选择器</button></li><li class="tab"><button type="button" data-href="#2-2">可继承属性</button></li><li class="tab"><button type="button" data-href="#2-3">不可继承属性</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><ul><li>通配(*)</li><li>标签选择器</li><li>类选择器</li><li>id选择器</li><li>相邻选择器(+)</li><li>后代选择器</li><li>子元素选择器</li><li>属性选择器(a[href])</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><ol><li>文字：font-size,color,line-height</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-3"><p>margin,padding,border</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="css优先级计算"><a href="#css优先级计算" class="headerlink" title="css优先级计算"></a>css优先级计算</h3><p><a href="https://coffepill.top/post/f4b15d3f.html">前端笔记&#x2F;样式覆盖问题</a></p><h3 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h3><p>设置三个角为透明</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    bodrder-<span class="attribute">top</span>:<span class="number">100px</span> soild transparent</span><br><span class="line">    border-right:<span class="number">100px</span> soild transparent</span><br><span class="line">    border-left:<span class="number">100px</span> soild transparent</span><br><span class="line">    border-bottom:<span class="number">100px</span> soild <span class="number">#000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对BFC规范（块级格式化上下文Block-formatting-context）的理解"><a href="#对BFC规范（块级格式化上下文Block-formatting-context）的理解" class="headerlink" title="对BFC规范（块级格式化上下文Block formatting context）的理解"></a>对BFC规范（块级格式化上下文Block formatting context）的理解</h3><p><code>BFC</code>就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素</p><p><strong>原则</strong>：如果一个元素具有BFC，则内部元素不管如何都不会影响外部元素</p><p><strong>触发条件</strong>：float非none;overflow非visible;display为inline-block等;position为absoute,fixed</p><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>static(默认)</td><td>没有定位</td></tr><tr><td>fixed</td><td>固定定位，参考系是浏览器窗口</td></tr><tr><td>relative</td><td>相对定位，相对于元素原本位置，当四个方向都有值时就只会取left,top</td></tr><tr><td>absolute</td><td>绝对定位，相对于父元素的位置,脱离文档流</td></tr><tr><td>sticky</td><td>黏性定位，是固定定位与相对定位的结合，当元素在页面视图内时，position 属性的值相当于 relative，当元素超出页面视图时，position 属性的值相当于 fixed</td></tr></tbody></table><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.l</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>,</span><br><span class="line">    height:<span class="number">100%</span>,</span><br><span class="line">    margin-left:-<span class="number">100%</span><span class="comment">/*将margin-left值调为负数，回到原来的一行*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.r</span>&#123;</span><br><span class="line"> <span class="attribute">width</span>:<span class="number">200px</span>,</span><br><span class="line">    height:<span class="number">100%</span></span><br><span class="line">    margin-left:-<span class="number">200px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.c</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>,</span><br><span class="line">    height:<span class="number">100%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c&quot;</span>&gt;</span>中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;l&quot;</span>&gt;</span>左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;r&quot;</span>&gt;</span>右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="css-reset"><a href="#css-reset" class="headerlink" title="css reset"></a>css reset</h3><p>重置css样式；但是性能差一点</p><h3 id="sprite-雪碧图，图片精灵"><a href="#sprite-雪碧图，图片精灵" class="headerlink" title="sprite(雪碧图，图片精灵)"></a>sprite(雪碧图，图片精灵)</h3><p>优点：减少http请求次数，提高性能</p><p>缺点：维护性能较差</p><h3 id="display-none与visiblity-hidden"><a href="#display-none与visiblity-hidden" class="headerlink" title="display:none与visiblity:hidden"></a>display:none与visiblity:hidden</h3><ol><li><code>display:none</code>不占位置，<code>visiblity:hidden</code>会占位置</li><li>两者都会产生重绘</li><li><code>display:none</code>还有产生一次回流</li></ol><blockquote><p>回流一定会造成重绘</p></blockquote><h3 id="opacity-x2F-rgba区别"><a href="#opacity-x2F-rgba区别" class="headerlink" title="opacity&#x2F;rgba区别"></a>opacity&#x2F;rgba区别</h3><ul><li><code>opacity</code>：取值0~1，属性会被继承，导致内容也变透明</li><li><code>rgba</code>:其中a取值也是0~1</li></ul><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="延时加载JS的方式（async-defer）"><a href="#延时加载JS的方式（async-defer）" class="headerlink" title="延时加载JS的方式（async defer）"></a>延时加载JS的方式（async defer）</h3><p>使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>两种方法区别：</p><ul><li>defer:等html全部解析完成，才会执行js代码，顺次执行</li><li>async: 和html同步执行，非顺次执行</li></ul><h3 id="null和undefined区别"><a href="#null和undefined区别" class="headerlink" title="null和undefined区别"></a>null和undefined区别</h3><p>null类型为一个表示空对象，undefined 为基础数据类型，<code>undefined转为数值时为NaN,null为0</code>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>==<span class="string">&#x27;undefined&#x27;</span>)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>==<span class="string">&#x27;object&#x27;</span>)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">undefined</span>))<span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">null</span>))<span class="comment">//0</span></span><br></pre></td></tr></table></figure><h3 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h3><p>微任务：promise.then()</p><p>宏任务：setTimeOut…</p><p>js代码执行流程：同步执行&#x3D;》事件循环(事件，请求，定时器等)【微任务&#x2F;宏任务】&#x3D;》微任务&#x3D;》宏任务</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><em>作用域</em></h3><ul><li>除了function外没有块级作用域</li><li>作用域链：内部可以访问外部，外部不能访问外部，<code>先寻找内部数据再查找外部数据</code></li><li>声明时没有加var相当于申明为window,全局变量</li><li>var声明会自动上升到最顶行，但是赋值还是在原行</li><li>优先级：声明变量&gt;声明普通函数&gt;参数&gt;变量提升</li></ul><h3 id="对象问题"><a href="#对象问题" class="headerlink" title="对象问题"></a>对象问题</h3><ul><li><p>对象通过new创建时，不会相等（&#x3D;&#x3D;&#x3D;）</p></li><li><p>引用类型</p></li><li><p>对象的key都是字符串类型</p></li><li><p>对象找属性&#x2F;方法</p><p>从对象本身找&#x3D;》构造函数中找&#x3D;》对象原型中&#x3D;》构造函数的原型中&#x3D;》对象上一层原型中</p></li></ul><h3 id="判断变量是不是数组"><a href="#判断变量是不是数组" class="headerlink" title="判断变量是不是数组"></a>判断变量是不是数组</h3><ul><li>Array.isArray()</li><li>instanceof (instanceof 在跨 frame 对象构建的场景下会失效)</li><li>Object.prototype.toString.call(arr).indexof(‘Array’)&gt;-1</li><li>Array.prototype.isPrototypeof()</li><li>arr.constructor.toString.indexOf(‘Array’)</li><li><code>判断一个js对象（arr）是否是Array，最准确的方法：Object.prototype.toString.call(arr) === &#39;[object Array]&#39;</code></li></ul><h3 id="取数组（arr）做大值"><a href="#取数组（arr）做大值" class="headerlink" title="取数组（arr）做大值"></a>取数组（arr）做大值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...arr)</span><br></pre></td></tr></table></figure><h3 id="找出字符串中出现次数最多的字符"><a href="#找出字符串中出现次数最多的字符" class="headerlink" title="找出字符串中出现次数最多的字符"></a>找出字符串中出现次数最多的字符</h3><p>思路：对出现的字符累加，找出累加次数最多的字符</p><h3 id="new操作符具体做了什么"><a href="#new操作符具体做了什么" class="headerlink" title="new操作符具体做了什么"></a>new操作符具体做了什么</h3><ol><li>创建了一个空对象</li><li>将空对象_proto_指向构造函数prototype</li><li>将空对象作为构造函数的上下文(改变this指向)</li><li>对构造函数有返回值的处理判断</li></ol><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><em>闭包</em></h3><p><strong>概念：</strong>闭包是一个函数加上到创建函数的作用域的链接，闭包“关闭”了函数的自由变量</p><p><strong>优点：</strong>内部函数可以访问外部函数的局部变量</p><p><strong>缺点：</strong>变量会驻留在内存中，造成内存损毁问题，在IE较低版本会造成内存泄漏</p><p>**解决:**把闭包函数设置为null</p><h3 id="闭包缺点"><a href="#闭包缺点" class="headerlink" title="闭包缺点"></a>闭包缺点</h3><p>过度使用闭包会导致内存泄漏，过多的内存泄露就会导致内存溢出</p><blockquote><p>内存泄漏：占用的内存没有及时释放，如意外的全局变量，没有及时清理的回调函数或计时器，闭包都会导致内存泄漏</p><p>内存溢出：程序运行错误，程序运行需要的内存超过剩余内存而抛出错误</p></blockquote><h3 id="对象属性赋值方法"><a href="#对象属性赋值方法" class="headerlink" title="对象属性赋值方法"></a>对象属性赋值方法</h3><p>对象.属性名&#x3D;值；</p><p>对象[属性]&#x3D;值；</p><p><strong>什么时候用[]:</strong></p><p>属性带有特殊符号：“-”或空格时只能用[]</p><p>属性是一个变量不确定</p><p><strong>什么时候只能用第一种：</strong></p><p>属性不存在时</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a><em>原型链</em></h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>对象共享属性与共享方法，对象有<code>_proto_</code>,<code>prototype</code>是函数特有的，<code>_proto_</code>指向构造函数的prototype</p><h4 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h4><ul><li>将原型串联起来</li><li>原型链顶端是null</li><li>函数 → 构造函数 → Function.prototype → Object.protype → null ;</li><li><img src="https://i.bmp.ovh/imgs/2022/08/13/8049a9d5991a4484.png" alt="image-20220812012044151"></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>ES6: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">parent</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5-原型链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title function_">parent</span>()</span><br></pre></td></tr></table></figure><p>借用构造函数中的call()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function child()&#123;</span><br><span class="line">parent.call(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻止冒泡事件与阻止默认事件"><a href="#阻止冒泡事件与阻止默认事件" class="headerlink" title="阻止冒泡事件与阻止默认事件"></a>阻止冒泡事件与阻止默认事件</h3><h4 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h4><p>可以直接在方法中调用<code>event.stopPropagation()</code>,jq中还可以使用<code>return false</code>，但是<code>return false</code>还会阻止事件本身</p><h4 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h4><p>使用<code>event.preventDefault();</code></p><h3 id="call、apply、bind区别"><a href="#call、apply、bind区别" class="headerlink" title="call、apply、bind区别"></a>call、apply、bind区别</h3><p>改变函数体内this指向</p><p><strong>语法</strong>：函数.call()</p><p><strong>区别</strong>：</p><ul><li>call与apply会立即执行，bind不会，会返回一个函数</li><li>参数不同：apply第二个参数是一个数组，call与bind需要一次罗列需要的参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(arr)</span><br></pre></td></tr></table></figure><h3 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>只复制引用，没有复制值</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>复制真正的值</p><h3 id="减少全局变量污染"><a href="#减少全局变量污染" class="headerlink" title="减少全局变量污染"></a>减少全局变量污染</h3><p>用一个全局变量作为一个容器，将其他变量写在这个全局变量中</p><p>利用匿名函数将脚本包裹起来</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>当一个对象没有任何变量或属性不引用，我们将永远无法操作该对象，但对象存在会暂用内存空间导致程序运行变慢。js本身存在自动垃圾回收机制，但对于非空对象需要我们手动的改为null，才会触发js的垃圾回收机制。</p><h3 id="this的4种绑定规则"><a href="#this的4种绑定规则" class="headerlink" title="this的4种绑定规则"></a>this的4种绑定规则</h3><ol><li><p>默认绑定</p><ul><li>全局环境中，this默认绑定到window</li><li>函数独立调用时，this默认绑定到window</li><li>被嵌套的函数独立调用时，this默认绑定到window</li><li>如果调用obj.foo()本身，foo()函数中的this指向调用函数的对象，即obj对象</li><li>IIFE立即执行函数实际上是函数声明后直接调用执行</li><li>闭包中内部函数的this默认指向window对象</li></ul></li><li><p>隐式绑定</p><p>当函数作为对象里的方法被调用时， <code>this</code> 是调用该函数的对象。</p></li><li><p>显示绑定（call。apply，bind）</p></li><li><p>new绑定</p></li></ol><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>利用 <a href="http://c.biancheng.net/view/9379.html">JS 事件冒泡</a>动态为元素绑定事件的方法称为事件委托（Event Delegation，也称为“事件代理”），是 JavaScript 中最热门的技术之一。</p><p>事件委托是利用事件的冒泡原理来实现的，大致可以分为三个步骤：</p><ol><li><p>确定要添加事件元素的父级元素；</p></li><li><p>给父元素定义事件，监听子元素的冒泡事件；</p></li><li><p>使用 event.target 来定位触发事件冒泡的子元素。</p></li><li><p>event.target.nodeName  　　 &#x2F;&#x2F;获取事件触发元素标签name</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">event.<span class="property">target</span>.<span class="property">id</span>　　　　　　　<span class="comment">//获取事件触发元素id</span></span><br><span class="line"> </span><br><span class="line">event.<span class="property">target</span>.<span class="property">className</span>　　  <span class="comment">//获取事件触发元素classname</span></span><br><span class="line"> </span><br><span class="line">event.<span class="property">target</span>.<span class="property">innerHTML</span>　　  <span class="comment">//获取事件触发元素的内容</span></span><br></pre></td></tr></table></figure><blockquote><p>e.currentTarget : 指的是绑定了事件监听的元素（可以理解为触发事件元素的父级元素）<br>e.target： 指的是真正触发事件的那个元素<br>事件冒泡是：如果绑定的事件对象子对象（比如点击页面上的button）时，e.currentTarget &#x3D;&#x3D; e.target： 指的是真正触发事件的那个元素如果绑定的事件对象是document时，e.currentTarget是document,而e.target 是btn</p></blockquote></li></ol><h2 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h2><h3 id="W3C"><a href="#W3C" class="headerlink" title="W3C"></a>W3C</h3><ul><li>W3C 指万维网联盟（<em>World Wide Web Consortium</em>）</li><li>万维网联盟标准不是某一个标准，而是一些列标准的<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>。网页主要有三部分组成：结构（Structure）、表现（Presentation）、行为（Behavior）。</li><li>结构化标准主要包括XHTML和XML，表现标准语言主要包括CSS、行为标准主要包括（如W3C DOM）、ECMAScript等</li></ul><h3 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h3><p><strong>1、语义化标签</strong></p><p><strong>2、<code>webStorage</code> 储存机制 <code>sessionStorage</code> 和 <code>localStorage</code></strong></p><p><strong>3、history 对象</strong></p><p><strong>4、表单元素的升级</strong></p><p>Html5给input新增加一些类型（search、email、number、tell、range、color、date）</p><p>升级：给表单元素新增加属性placeholder（给表单元素设置提示信息）</p><p>升级：提供了新的下拉框方式</p><p><strong>5、多媒体</strong></p><p><strong>6、用于绘画的 canvas</strong></p><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>意图性与维护性提高；seo成分更好</p><h3 id="关闭ios键盘首字母大写"><a href="#关闭ios键盘首字母大写" class="headerlink" title="关闭ios键盘首字母大写"></a>关闭ios键盘首字母大写</h3><p>属性<code>autocapitalize</code>设置为”off”</p><h3 id="设置Chorme支持小于12px的字体"><a href="#设置Chorme支持小于12px的字体" class="headerlink" title="设置Chorme支持小于12px的字体"></a>设置Chorme支持小于12px的字体</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-tranform:<span class="built_in">scale</span>(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><h3 id="去除ios元素被触摸时产生半透明灰色遮罩"><a href="#去除ios元素被触摸时产生半透明灰色遮罩" class="headerlink" title="去除ios元素被触摸时产生半透明灰色遮罩"></a>去除ios元素被触摸时产生半透明灰色遮罩</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-tap-heighLight-<span class="attribute">color</span>:<span class="built_in">ragb</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="禁止长按触发系统菜单，下载图片"><a href="#禁止长按触发系统菜单，下载图片" class="headerlink" title="禁止长按触发系统菜单，下载图片"></a>禁止长按触发系统菜单，下载图片</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch-callout:none</span><br></pre></td></tr></table></figure><blockquote><p>禁止选中文字<code>user-select:none</code></p></blockquote><h3 id="自适应（适配）"><a href="#自适应（适配）" class="headerlink" title="自适应（适配）"></a>自适应（适配）</h3><h4 id="移动端-淘宝无限适配"><a href="#移动端-淘宝无限适配" class="headerlink" title="移动端-淘宝无限适配"></a>移动端-淘宝无限适配</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;flexible.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>一个URL可以响应多端</p><h4 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">100px</span>)&#123;</span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:none</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*only 可以排除不支持媒体查询的浏览器*/</span></span><br><span class="line"><span class="comment">/*screen 设备类型*/</span></span><br><span class="line"><span class="comment">/*max-height|max-width*/</span></span><br><span class="line"><span class="comment">/*min-height|min-width*/</span></span><br></pre></td></tr></table></figure><h3 id="布局方案"><a href="#布局方案" class="headerlink" title="布局方案"></a>布局方案</h3><h4 id="什么使用响应式"><a href="#什么使用响应式" class="headerlink" title="什么使用响应式"></a>什么使用响应式</h4><p>访问量小，数据量不大，纯展示类的项目适合</p><h4 id="pc-移动端"><a href="#pc-移动端" class="headerlink" title="pc+移动端"></a>pc+移动端</h4><p>pc一套，加入少量响应式</p><p>移动端一套，使用自适应</p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="ES6-1"><a href="#ES6-1" class="headerlink" title="ES6"></a>ES6</h3><p>ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准</p><p>ES6新增的一些特性：<br>1）let声明变量和const声明常量，两个都有块级作用域ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明<br>2）箭头函数ES6中的函数定义不再使用关键字function()，而是利用了()&#x3D;&gt;来进行定义<br>3）模板字符串模板字符串是增强版的字符串，用反引号（&#96;）标识，可以当作普通字符串使用，也可以用来定义多行字符串<br>4）解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值<br>5）for of循环for…of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串<br>6）import、export导入导出ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用<br>7）set数据结构Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数<br>8）… 展开运算符可以将数组或对象里面的值展开；还可以将多个值收集为一个变量<br>9）修饰器 @decorator是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数<br>10）class 类的继承ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念11）async、await使用 async&#x2F;await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成<br>12）Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大<br>13）Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的<br>14）Proxy代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情</p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p> (Document Object Model) 译为<strong>文档对象模型</strong>，是 HTML 和 XML 文档的编程接口。DOM 是 W3C（万维网联盟）的标准。</p><p>W3C DOM 标准被分为 3 个不同的部分：</p><ul><li>核心 DOM - 针对任何结构化文档的标准模型</li><li>XML DOM - 针对 XML 文档的标准模型</li><li>HTML DOM - 针对 HTML 文档的标准模型</li></ul><h3 id="堆-x2F-栈存储"><a href="#堆-x2F-栈存储" class="headerlink" title="堆&#x2F;栈存储"></a>堆&#x2F;栈存储</h3><p>JS中数据对于存储可以分为两种数据类型：基本类型和引用类型<br>基本类型：Number，String，Boolean，Null，Undefined<br>这些类型的值存放在栈区，函数调用时传递的是变量的值(值)。<br>引用类型：Object，Array，Function<br>这些类型的对象存放在堆区，对象的地址存放在栈区，函数调用时传递的是对象的地址(址)。</p><h3 id="重绘和重排（回流）"><a href="#重绘和重排（回流）" class="headerlink" title="重绘和重排（回流）"></a>重绘和重排（回流）</h3><p>重绘:当元素的一部分属性发生改变，如外观、背景、颜色等不会引起布局变化，只需要浏览器根据元素的新属性重新绘制    ，使元素呈现新的外观叫做重绘。 </p><p>重排（回流）:当render树中的一部分或者全部因为大小边距等问题发生改变而需要DOM树重新计算的过程重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）</p><h3 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var,let,const"></a>var,let,const</h3><p>区别：</p><ul><li>var有变量提升机制，另外两个没有</li><li>var可以多次申明同一变量</li><li>var&#x2F;let申明变量，const申明常量不可以重复赋值</li><li>let&#x2F;const有自身作用域，var没有自身作用域</li></ul><h3 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h3><ul><li>Object.assign()</li><li>var c&#x3D;{…a,…b}</li><li>用for循环加入</li></ul><h3 id="箭头函数与普通函数区别"><a href="#箭头函数与普通函数区别" class="headerlink" title="箭头函数与普通函数区别"></a>箭头函数与普通函数区别</h3><ol><li><p>this指向</p><p>箭头函数中的this只在箭头函数定义时决定，不可通过call等修改</p><p>取决于外层第一个普通函数的this</p></li><li><p>箭头函数不能作为构造函数</p></li><li><p>箭头函数没有prototype</p></li><li><p>也没有argument</p></li></ol><h3 id="Promise有几种状态"><a href="#Promise有几种状态" class="headerlink" title="Promise有几种状态"></a>Promise有几种状态</h3><ul><li><p>pending(进行中)</p></li><li><p>fulfilled（已成功）</p></li><li><p>rejected（已失败）</p><p>promise对象的方法：then、catch、all、race、allsettled</p><blockquote><p>allsetled可以理解为结合了all和race特点的方法</p></blockquote></li></ul><h3 id="promise原理"><a href="#promise原理" class="headerlink" title="promise原理"></a>promise原理</h3><p>pending<code>是对象创建后的初始状态，当对象</code>fulfill<code>（成功）时变为</code>fulfilled<code>，当对象</code>reject<code>（失败）时变为</code>rejected<code>。且只能从</code>pengding<code>变为</code>fulfilled<code>或</code>rejected <code>，而不能逆向或从</code>fulfilled<code>变为</code>rejected <code>、从</code>rejected<code>变为</code>fulfilled</p><h3 id="什么是-IIFE，-应用场景？"><a href="#什么是-IIFE，-应用场景？" class="headerlink" title="什么是 IIFE， 应用场景？"></a>什么是 IIFE， 应用场景？</h3><p>IIFE：立即执行函数<br>IIFE中定义的任何变量和函数，都会在执行结束时被销毁。适合做初始化工作。</p><h3 id="event获取键盘输入值"><a href="#event获取键盘输入值" class="headerlink" title="event获取键盘输入值"></a>event获取键盘输入值</h3><p>在实例中，我们使用了支持多浏览器的方法，因为 keyCode 属性无法再 Firefox 浏览器中工作。但是 which 属性可以。<br>如果浏览器支持 event.which 则使用 event.which，否则使用 event.keyCode</p><h3 id="严格模式–user-strict"><a href="#严格模式–user-strict" class="headerlink" title="严格模式–user strict"></a>严格模式–user strict</h3><p><strong>使用</strong>：在对应js文件代码中申明<code>&quot;use strict&quot;;</code>，在函数内申明只在函数中生效</p><p><strong>为什么使用严格模式</strong></p><ul><li><p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</p></li><li><p>消除代码运行的一些不安全之处，保证代码运行的安全；</p></li><li><p>提高编译器效率，增加运行速度；</p></li><li><p>为未来新版本的Javascript做好铺垫。</p></li></ul><p><strong>限制</strong></p><ul><li>不允许使用未声明的变量</li><li>不支持arguments、caller、callee、with；</li><li>禁止this关键字指向全局对象。因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</li><li>不允许不使用 var 关键字去创建全局变量，抛出 ReferenceError</li><li>不允许对变量使用 delete 操作符，抛 ReferenceError</li><li>不可对对象的只读属性赋值，不可对对象的不可配置属性使用 delete 操作符，不可为不可拓展的对象添加属性，均抛 TypeError</li><li>对象属性名必须唯一</li><li>函数中不可有重名参数</li><li>在函数内部对修改参数不会反映到 arguments 中</li><li>淘汰 arguments.callee 和 arguments.caller</li><li>不可在 if 内部声明函数</li><li>抛弃 with 语句</li></ul><p><strong>保留关键字</strong></p><p>为了向将来Javascript的新版本过渡，严格模式新增了一些保留关键字：</p><ul><li>implements</li><li>interface</li><li>let</li><li>package</li><li>private</li><li>protected</li><li>public</li><li>static</li><li>yield</li></ul><h3 id="web-worker"><a href="#web-worker" class="headerlink" title="web worker"></a>web worker</h3><p>Web Workers 使得一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。</p><p>它的作用就是给JS创造多线程运行环境，允许主线程创建worker线程，分配任务给后者，主线程运行的同时worker线程也在运行，相互不干扰，在worker线程运行结束后把结果返回给主线程。</p><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(jsUrl, options)</span><br></pre></td></tr></table></figure><p>Worker()构造函数，第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;worker.js&#x27;</span>, &#123; name : <span class="string">&#x27;myWorker&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">self.<span class="property">name</span> <span class="comment">// myWorker</span></span><br></pre></td></tr></table></figure><p>Worker 线程和主线程都通过 <code>postMessage()</code> 方法发送消息，通过 <code>onmessage</code> 事件接收消息。在这个过程中数据并不是被共享的，而是被复制的。<code>Error</code> 和 <code>Function</code> 对象不能被结构化克隆算法复制，如果尝试这么做的话会导致抛出 <code>DATA_CLONE_ERR</code> 的异常。另外，<code>postMessage()</code> 一次只能发送一个对象， 如果需要发送多个参数可以将参数包装为数组或对象再进行传递。</p><p>在 Worker 线程中，<code>self</code> 和 <code>this</code> 都代表子线程的全局对象</p><p>可以在主线程中使用 <code>terminate()</code> 方法或在 Worker 线程中使用 <code>close()</code> 方法关闭 worker。</p><p>Web Worker 提供了 <code>importScripts()</code> 方法，<strong>能够将外部脚本文件加载到 Worker 中。</strong></p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>解构赋值是对赋值运算符的扩展。</p><p>在解构中，有下面两部分参与：</p><ul><li>解构的源，解构赋值表达式的右边部分。</li><li>解构的目标，解构赋值表达式的左边部分。</li></ul><h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><p><code>async</code> 函数返回一个 <code>Promise</code> 对象，可以使用 then 方法添加回调函数。</p><p><code>async</code> 函数中可能会有 <code>await</code> 表达式，<code>async</code> 函数执行时，如果遇到 <code>await</code> 就会先暂停执行 ，等到触发的异步操作完成后，恢复 <code>async</code> 函数的执行并返回解析值。</p><p><code>await</code> 操作符用于等待一个 Promise 对象, 它只能在异步函数 <code>async function</code> 内部使用。</p><h3 id="find和filter区别"><a href="#find和filter区别" class="headerlink" title="find和filter区别"></a>find和filter区别</h3><p>filter返回数组，返回所有匹配结果，如果都不匹配就全返回</p><p>find返回具体内容，即第一个匹配结果</p><h3 id="some和every区别"><a href="#some和every区别" class="headerlink" title="some和every区别"></a>some和every区别</h3><p>some数组有一项匹配返回true,every全部匹配才会返回true</p><h3 id="es6用rest替代arguments"><a href="#es6用rest替代arguments" class="headerlink" title="es6用rest替代arguments"></a>es6用rest替代arguments</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...arg</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment">//[1,2,3] 输出为数组 argumrnts是伪数组</span></span><br></pre></td></tr></table></figure><h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><h3 id="渐进式框架"><a href="#渐进式框架" class="headerlink" title="渐进式框架"></a>渐进式框架</h3><p>用户通过需求渐进式的加入需要的插件依赖</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><em>beforeCreate();created();beforeMounted();mounted();beforeUpdate();updated();beforeDestroy();destroyed()</em></p><p><strong>进入页面就会产生的生命周期</strong></p><p><em>beforeCreate();created();beforeMounted();mounted()；</em></p><table><thead><tr><th></th><th>$el</th><th>$data</th></tr></thead><tbody><tr><td>beforeCreat</td><td>无</td><td>无</td></tr><tr><td>created</td><td>无</td><td>有</td></tr><tr><td>beforeMounted</td><td>无</td><td>有</td></tr><tr><td>mounted</td><td>有</td><td>有</td></tr></tbody></table><blockquote><p>如果加入keep-alive会产生<code>activated,deactivated</code>两个生命周期</p></blockquote><p>加入keep-alive后第一次进入会执行<em>beforeCreate();created();beforeMounted();mounted()；activated()</em></p><p>之后进入只会执行<code>activated()</code></p><h3 id="对keep-alive的理解"><a href="#对keep-alive的理解" class="headerlink" title="对keep-alive的理解"></a>对keep-alive的理解</h3><p>vue的一个组件，用来缓存组件，提高性能</p><p><strong>使用场景</strong></p><p>如商品详情页</p><h3 id="v-if与v-show"><a href="#v-if与v-show" class="headerlink" title="v-if与v-show"></a>v-if与v-show</h3><p>使用场景：</p><pre><code>初次加载v-if要比v-show好，不会做加载盒子；频繁切换v-show好，创建和删除开销太大，显示和隐藏开销小</code></pre><h3 id="v-if与v-for优先级"><a href="#v-if与v-for优先级" class="headerlink" title="v-if与v-for优先级"></a>v-if与v-for优先级</h3><p>v-for&gt;v-if,两者不能写在同一标签中</p><h3 id="computed-methods-watch"><a href="#computed-methods-watch" class="headerlink" title="computed,methods,watch"></a>computed,methods,watch</h3><p>computed是有缓存的，methods没有；</p><p>watch是监听，数据改变时才会触发，computed不需要；computed需要返回值，watch不需要</p><h3 id="props-data优先级"><a href="#props-data优先级" class="headerlink" title="props,data优先级"></a>props,data优先级</h3><p>props&gt;methods&gt;data&gt;computed&gt;watch</p><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><strong>State,Getters,Mutations,Actions,Modules</strong></p><p>对应有<code>mapSatate</code>,<code>mapGetters</code>,<code>mapActions</code>,<code>mapMutations</code></p><h4 id="vuex是单向数据流"><a href="#vuex是单向数据流" class="headerlink" title="vuex是单向数据流"></a>vuex是单向数据流</h4><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>1.用localStroge</p><p>2.持久化插件</p><h3 id="跨域代理"><a href="#跨域代理" class="headerlink" title="跨域代理"></a>跨域代理</h3><p>config.js-&gt;defineConfig-&gt;devServer-&gt;proxy&#x2F;proxytable(target&#x2F;&#x2F;跨域地址； changOrigin: true,  &#x2F;&#x2F;允许跨域；pathRewrite重写路径)</p><h3 id="vue路由模式"><a href="#vue路由模式" class="headerlink" title="vue路由模式"></a>vue路由模式</h3><p>有两种：hash;history</p><p>跳转请求：history：发送请求；hash:不发送请求</p><h3 id="vue-router的两种模式的区别"><a href="#vue-router的两种模式的区别" class="headerlink" title="vue-router的两种模式的区别"></a>vue-router的两种模式的区别</h3><p>hash模式：<br>1、url路径会出现 # 字符<br>2、hash值不包括在 HTTP 请求中，它是交由前端路由处理，所以改变hash值时不会刷新页面，也不会向服务器发送请求<br>3、hash值的改变会触发onhashchange事件</p><p>history模式：<br>1、整个地址重新加载，可以保存历史记录，方便前进后退<br>2、使用 HTML5 API（旧浏览器不支持）和 HTTP服务端配置，没有后台配置的话，页面刷新时会出现404</p><p>3、API： history api可以分为两大部分，切换历史状态和修改历史状态：</p><ul><li><strong>修改历史状态</strong>：包括了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。</li><li><strong>切换历史状态：</strong> 包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。</li></ul><h3 id="vue路径传值"><a href="#vue路径传值" class="headerlink" title="vue路径传值"></a>vue路径传值</h3><p>1.显示:<code>query</code></p><p>2.隐式:<code>params</code></p><h3 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h3><ul><li><p><strong>全局</strong></p><p>beforeEach,beforeResolve,afterEach</p></li><li><p><strong>路由独享</strong></p><p>beforeEnter</p></li><li><p><strong>组件内</strong></p><p>beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave</p></li></ul><h3 id="双向绑定的原理"><a href="#双向绑定的原理" class="headerlink" title="双向绑定的原理"></a>双向绑定的原理</h3><p>是通过数据劫持，并结合发布-订阅模式的方法实现的，也就是说数据和视图同步，数据发生变化，试图跟着变化，视图变化，数据跟着变化</p><p>核心是<code>Object.defineProerty()</code>方法</p><blockquote><p>1.Object.defineProperty(obj,prop,descriptor)这个语法内有三个参数，分别是obj（要定义其上属性的对象） prop （要定义或修改的属性）descriptor （具体的改变方法）<br>2.简单的说 就是用这个方法来定义一个值。当调用时我们使用了它里面的get方法，当我们给这个属性赋值的时候，又用到了它里面的set方法</p></blockquote><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p><ul><li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li><li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li><li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li></ul><h3 id="vuex-1"><a href="#vuex-1" class="headerlink" title="vuex"></a>vuex</h3><p>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。<br>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。<br>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。<br>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。<br>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</p><h3 id="vue-路由懒加载"><a href="#vue-路由懒加载" class="headerlink" title="vue-路由懒加载"></a>vue-路由懒加载</h3><div class="tabs" id="标签区别"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#标签区别-1">Vue异步组件技术</button></li><li class="tab"><button type="button" data-href="#标签区别-2">动态import语法</button></li><li class="tab"><button type="button" data-href="#标签区别-3">require.ensure()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="标签区别-1"><p>结合vue的<a href="https://link.juejin.cn/?target=https://cn.vuejs.org/v2/guide/components-dynamic-async.html%23%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6">异步组件</a>和Webpack的代码分割功能可以实现路由组件的懒加载。打包后，每一个组件生成一个js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">path</span>: <span class="string">&#x27;/Demo&#x27;</span>,  <span class="attr">name</span>: <span class="string">&#x27;Demo&#x27;</span>,  *<span class="comment">//打包后，每个组件单独生成一个chunk文件*  </span></span><br><span class="line">    <span class="attr">component</span>: <span class="function"><span class="params">reslove</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;../views/Demo&#x27;</span>], resolve) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="标签区别-2"><ul><li>如果使用的是Bable，你将需要添加<a href="https://link.juejin.cn/?target=https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/">syntax-dynamic-import</a>插件， 才能使Babel可以正确的解析语法。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = () =&gt; <span class="keyword">import</span>(<span class="string">&#x27;../views/Demo&#x27;</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="标签区别-3"><ul><li>使用webpacke的<a href="https://link.juejin.cn/?target=https://webpack.docschina.org/api/module-methods%23require-ensure">require.ensure</a>也可以实现按需加载。</li><li>require.ensure()是webpack特有的，现在已经被import()取代。</li><li>这个特性依赖于内置的promise，低版本浏览器使用require.ensure需要考虑是否支持es6</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><ol><li>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。</li><li>Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li></ol><h3 id="双花括号与v-text-v-html区别"><a href="#双花括号与v-text-v-html区别" class="headerlink" title="双花括号与v-text,v-html区别"></a>双花括号与v-text,v-html区别</h3><p>双花括号：将数据解析为纯文本，不能输出真正的html，在页面加载时显示双花括号，所以通常使用v-html和v-text代替，且花括号方式在以后可能被取消</p><p>v-html&#x3D;”html”：输出真正的html</p><p>v-text&#x3D;”text”：将数据解析为纯文本，不能输出真正的html，与花括号的区别是在页面加载时不显示双花括号</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM*"></a>MVVM*</h3><hr><h2 id="2022-x2F-9-x2F-7-补充"><a href="#2022-x2F-9-x2F-7-补充" class="headerlink" title="2022&#x2F;9&#x2F;7 补充"></a>2022&#x2F;9&#x2F;7 补充</h2><h3 id="从输入url到页面渲染中间发生什么"><a href="#从输入url到页面渲染中间发生什么" class="headerlink" title="从输入url到页面渲染中间发生什么"></a><a href="https://www.cnblogs.com/dylAlex/p/14878618.html">从输入url到页面渲染中间发生什么</a></h3><p>总体来说分为以下几个过程：</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="js跨域"><a href="#js跨域" class="headerlink" title="js跨域"></a>js跨域</h3><p><a href="https://www.jb51.net/article/97611.htm">js前端解决跨域问题的8种方案（最新最全）_javascript技巧_脚本之家 (jb51.net)</a></p><p><strong>注</strong>：</p><p>第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，</p><p>第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。</p><p>“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。<br><strong>1.document.domain + iframe   (只有在主域相同的时候才能使用该方法)</strong></p><p><strong>2. 动态创建script</strong>\</p><p><strong>3&gt; location.hash + iframe</strong></p><p> <strong>4&gt; window.name + iframe</strong></p><p><strong>5&gt; postMessage（HTML5中的XMLHttpRequest Level 2中的API）</strong></p><ol><li>a.com&#x2F;index.html中的代码：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;ifr&quot;</span> <span class="attr">src</span>=<span class="string">&quot;b.com/index.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">var</span> ifr = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ifr&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">var</span> targetOrigin = <span class="string">&#x27;http://b.com&#x27;</span>; <span class="comment">// 若写成&#x27;http://b.com/c/proxy.html&#x27;效果一样</span></span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 若写成&#x27;http://c.com&#x27;就不会执行postMessage了</span></span></span><br><span class="line"><span class="language-javascript"> ifr.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;I was there!&#x27;</span>, targetOrigin);</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>b.com&#x2F;index.html中的代码：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 通过origin属性判断消息来源地址</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (event.<span class="property">origin</span> == <span class="string">&#x27;http://a.com&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">   <span class="title function_">alert</span>(event.<span class="property">data</span>); <span class="comment">// 弹出&quot;I was there!&quot;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="title function_">alert</span>(event.<span class="property">source</span>); <span class="comment">// 对a.com、index.html中window对象的引用</span></span></span><br><span class="line"><span class="language-javascript">         <span class="comment">// 但由于同源策略，这里event.source不可以访问window对象</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"> &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>6&gt; CORS</strong></p><p>IE中对CORS的实现是xdr,其它浏览器中的实现就在xhr中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCORS</span>(<span class="params">method, url</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"> <span class="keyword">if</span>(<span class="string">&#x27;withCredentials&#x27;</span> <span class="keyword">in</span> xhr)&#123;</span><br><span class="line">  xhr.<span class="title function_">open</span>(method, url, <span class="literal">true</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="title class_">XDomainRequest</span> != <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XDomainRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  xhr = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> request = <span class="title function_">createCORS</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.baidu.com&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(request)&#123;</span><br><span class="line"> request.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  ......</span><br><span class="line"> &#125;;</span><br><span class="line"> request.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7. JSONP</strong></p><pre><code>JSONP包含两部分：回调函数和数据。 **jsonp虽然很简单，但是有如下缺点：**1）安全问题(请求代码中可能存在安全隐患)2）要确定jsonp请求是否失败并不容易</code></pre><p><strong>8.web sockets</strong></p><p>web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> <span class="title class_">WebSockt</span>(<span class="string">&#x27;ws://www.baidu.com&#x27;</span>);<span class="comment">//http-&gt;ws; https-&gt;wss</span></span><br><span class="line">socket.<span class="title function_">send</span>(<span class="string">&#x27;hello WebSockt&#x27;</span>);</span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> data = event.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2022-x2F-09-x2F-13"><a href="#2022-x2F-09-x2F-13" class="headerlink" title="2022&#x2F;09&#x2F;13"></a>2022&#x2F;09&#x2F;13</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="readStatea状态码"><a href="#readStatea状态码" class="headerlink" title="readStatea状态码"></a>readStatea状态码</h4><p>0：初始值，表示请求未初始化，open方法尚未调用；</p><p>1：启动请求，open 方法已经调用，但尚未调用 send 方法；</p><p>2：请求发送，已经调用 send 方法，但尚未接收到响应；</p><p>3：接收响应，已经接受到部分响应数据，主要是响应头；、</p><p>4：HTTP 响应完成，已经接收到全部响应数据，而且可以在客户端使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听状态码的改变</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span>=<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 请求成功时，执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span>==<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">response</span>)            </span><br><span class="line">&#125;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置请求头（setRequestHeader）"><a href="#设置请求头（setRequestHeader）" class="headerlink" title="设置请求头（setRequestHeader）"></a>设置请求头（setRequestHeader）</h4><p><code>Content-Type</code>的类型：</p><ul><li><code>text/html</code>表示提交xml类型的数据</li><li><code>application/x-www-form-urlencoded</code>表示常见的form表单提交&#x2F;web提交</li><li><code>application/json</code>提交json类型数据</li><li><code>mulltipart/formdata</code>表示文件提交</li></ul><h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h3><p>GET请求一般是用来获取数据的，POST请求一般是用来提交数据的</p><p>GET请求浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；POST请求浏览器先发送header，服务器响应100 continue ，浏览器再发送data，服务器响应200ok</p><h2 id="2022-x2F-9-x2F-34补充"><a href="#2022-x2F-9-x2F-34补充" class="headerlink" title="2022&#x2F;9&#x2F;34补充"></a>2022&#x2F;9&#x2F;34补充</h2><h3 id="模块化方法"><a href="#模块化方法" class="headerlink" title="模块化方法"></a>模块化方法</h3><ul><li><p>commonjs</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由nodejs实现</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>ESM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 由es6实现</span><br><span class="line">import $ from &quot;jquery&quot;;</span><br><span class="line">export default $;</span><br></pre></td></tr></table></figure></li><li><p>AMD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 由RequireJS实现</span><br><span class="line">define([&quot;juqery&quot;, &quot;vue&quot;], function ($, Vue) &#123;</span><br><span class="line">  // 依赖必须一开始就写好</span><br><span class="line">  $(&quot;#app&quot;);</span><br><span class="line">  new Vue(&#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>CMD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 由SeaJS 实现</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var a = require(&#x27;./a&#x27;)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // ....</span><br><span class="line">    var b = require(&#x27;./b&#x27;) // 依赖可以就近书写</span><br><span class="line">    b.doSomething()</span><br><span class="line">   // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>UMD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function (global, factory) &#123;</span><br><span class="line">  typeof exports === &#x27;object&#x27; &amp;&amp; typeof module !== &#x27;undefined&#x27; ? module.exports = factory() :</span><br><span class="line">  typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define(factory) :</span><br><span class="line">  (global = global || self, global.Vue = factory());</span><br><span class="line">&#125;(this, function () &#123; &#x27;use strict&#x27;&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h2&gt;&lt;h3 id=&quot;行内元素-x2F-块级元素&quot;&gt;&lt;a href=&quot;#行内元素-x2F-块级元素&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="前端面试" scheme="https://coffepill.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>工作日记（记录写项目时遇到的一些问题）</title>
    <link href="https://coffepill.top/post/15f95e80.html"/>
    <id>https://coffepill.top/post/15f95e80.html</id>
    <published>2022-08-07T14:32:07.000Z</published>
    <updated>2022-08-07T16:14:00.414Z</updated>
    
    <content type="html"><![CDATA[<div class="note default modern"><p>主要记录在写项目时遇到的一些问题</p></div><blockquote><p>用到的主键库是<code>iView</code>组件库，跟<code>elementui</code>的组件差别不是很大，但是组件数量跟功能还是有所欠缺，有点是没有高度的封装反倒对一些自定义更简单</p></blockquote><h5 id="单选框绑定的如果是数字要用-label"><a href="#单选框绑定的如果是数字要用-label" class="headerlink" title="单选框绑定的如果是数字要用:label"></a>单选框绑定的如果是数字要用<code>:label</code></h5><h5 id="复选框默认值要设为空数组"><a href="#复选框默认值要设为空数组" class="headerlink" title="复选框默认值要设为空数组"></a>复选框默认值要设为空数组</h5><h5 id="下拉框value为数字时，规则需要写上type-‘number’"><a href="#下拉框value为数字时，规则需要写上type-‘number’" class="headerlink" title="下拉框value为数字时，规则需要写上type:‘number’"></a>下拉框value为数字时，规则需要写上<code>type:‘number’</code></h5><h5 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h5><p>map函数，简单用法：<code>arr.map(item=&gt;&#123;return item&#125;)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), thisIndex)</span><br></pre></td></tr></table></figure><h5 id="自动填充输入框"><a href="#自动填充输入框" class="headerlink" title="自动填充输入框"></a>自动填充输入框</h5><p>使用<code>&lt;AutoComplete&gt;</code>标签，<code>data</code>对应填充数据集，<code>@on-search</code>对应输入后的响应函数，一般就是在这个函数内对<code>data</code>的数据进行处理，但是还是要注意每次填充后对<code>data</code>的数据进行清理</p><h5 id="对事件选择器的选项进行限制–（如限制只能选择今天及以后）"><a href="#对事件选择器的选项进行限制–（如限制只能选择今天及以后）" class="headerlink" title="对事件选择器的选项进行限制–（如限制只能选择今天及以后）"></a>对事件选择器的选项进行限制–（如限制只能选择今天及以后）</h5><p>利用<code>watch</code>监听<code>&lt;DatePicker&gt;</code>的数值变化，控制<code>options</code>属性对应的数值内容，<code>options</code>中有一函数返回不能被选择的数值<code>disabledDate(date)</code></p><p><strong>具体用法</strong></p><p>HTML:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;DatePicker</span><br><span class="line">              type=&quot;date&quot;</span><br><span class="line">              :options=&quot;startOption&quot;</span><br><span class="line">              v-model=&quot;formItem.verifyEndTime&quot;</span><br><span class="line">              placeholder=&quot;yyyy-MM-dd HH:mm:ss&quot;</span><br><span class="line">            &gt;&lt;/DatePicker&gt;</span><br></pre></td></tr></table></figure><p>JavaScript：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;formItem.endData&quot;</span>() &#123;</span><br><span class="line">      <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">startOption</span> = &#123;</span><br><span class="line">        <span class="title function_">disabledDate</span>(<span class="params">date</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">          <span class="keyword">return</span> date.<span class="title function_">getTime</span>() &lt; <span class="title class_">Date</span>.<span class="title function_">now</span>() - <span class="number">8.64e7</span>; <span class="comment">// 如果没有后面的-8.64e7就是不可以选择今天的</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="comment">//这里的endData是另外一个时间选择器的值，如果不需要互相监听也可以直接在周期函数里对options进行初始化</span></span><br><span class="line">      </span><br></pre></td></tr></table></figure><h5 id="自定义时间格式"><a href="#自定义时间格式" class="headerlink" title="自定义时间格式"></a>自定义时间格式</h5><p>参考<a href="https://blog.csdn.net/qq_36649922/article/details/117412208">Vue iView时间组件DatePicker，设置开始时间和结束时间约束、初始值和格式（年月日）_Taeyeon-IU的博客-CSDN博客_iview时间格式</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 这是因为iview的时间选择器绑定后获取的值是中国标准时间，不是我们想要的标准时间</span><br><span class="line">    handleSubmit() &#123;</span><br><span class="line">        let startDate = this.getNowFormDate(this.createForm.startDate);</span><br><span class="line">        let endDate = this.getNowFormDate(this.createForm.endDate);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 日期格式转换</span><br><span class="line">    getNowFormDate(date) &#123;</span><br><span class="line">        let year = date.getFullYear();</span><br><span class="line">        let month = date.getMonth() + 1;</span><br><span class="line">        let day = date.getDate();</span><br><span class="line">        if(month &gt;= 1 &amp;&amp; month &lt;= 9) &#123;</span><br><span class="line">            month = &#x27;0&#x27; + month;</span><br><span class="line">        &#125;</span><br><span class="line">        if(day &gt;= 1 &amp;&amp; day &lt;= 9) &#123;</span><br><span class="line">            day = &#x27;0&#x27; + day;</span><br><span class="line">        &#125;</span><br><span class="line">        let currentdate = &#x27;$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;&#x27;;</span><br><span class="line">        return currentdate;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>虽然，iview时间选择器有一个formate属性，可以设置显示的时间格式，但是获取到的还是中国标准时间，所以就直接用这种方法。</p><h5 id="对文件进行上传"><a href="#对文件进行上传" class="headerlink" title="对文件进行上传"></a>对文件进行上传</h5><p>一般来说真实的项目都需要设置请求头，之后是设置文件上传的路径即接口</p><p>这里写的是一个手动上传的接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Upload</span><br><span class="line">          ref=&quot;uploadFile&quot;</span><br><span class="line">          accept=&quot;.xls, .xlsx&quot;</span><br><span class="line">          :before-upload=&quot;handleUpload&quot;</span><br><span class="line">          :on-error=&quot;uploadError&quot;</span><br><span class="line">          :action=&quot;uploadUrl&quot;</span><br><span class="line">          :headers=&quot;headers&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;Button icon=&quot;ios-cloud-upload-outline&quot;&gt;选择文件&lt;/Button&gt;</span><br><span class="line">        &lt;/Upload&gt;</span><br><span class="line">&lt;!--accept对上传文件进行限制，befo-upload阻止上传return fales; action对应接口地址；headers为请求头 -&gt;</span><br></pre></td></tr></table></figure><p>data</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="title class_">Authorization</span>: <span class="title function_">getToken</span>() ? <span class="string">&quot;Bearer&quot;</span> + <span class="title function_">getToken</span>() : <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><p>手动上传就直接调用upload组件的post方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 阻止上传</span></span><br><span class="line">    <span class="title function_">handleUpload</span>(<span class="params">file</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">file</span>.<span class="title function_">push</span>(file);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="title function_">importFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">uploadFile</span>.<span class="title function_">post</span>(<span class="variable language_">this</span>.<span class="property">file</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">file</span> = [];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isImport</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h5 id="通过搜索快速查找树形组件的某个节点"><a href="#通过搜索快速查找树形组件的某个节点" class="headerlink" title="通过搜索快速查找树形组件的某个节点"></a>通过搜索快速查找树形组件的某个节点</h5><p>具体可以看这篇<a href="https://blog.csdn.net/liangziqi233/article/details/120070757">【Vue.js—iView—Tree 树形控件】树的搜索，输入节点名称，选中该节点并展开它的父节点_悄羊羊的博客-CSDN博客</a></p><p>实现思路就是查找到搜索框对应值的节点位置，再通过递归对应节点，调用节点的属性<code>expand</code>即可</p><h5 id="打开pdf文件"><a href="#打开pdf文件" class="headerlink" title="打开pdf文件"></a>打开pdf文件</h5><p>这个是用<code>vue-pdf</code>实现，但是要实现自己需要的效果就需要手动加入对应的样式，这个插件只是提供了跳转页数等属性</p><p>在下载依赖时需要注意自己<code>node.js</code>版本，如果<strong>版本太高</strong>，下载依赖时就会出错，导致组件无法使用</p><hr><div class="note modern"><p>这次还开始尝试对一些常用组件进行封装，具体还在整理</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note default modern&quot;&gt;&lt;p&gt;主要记录在写项目时遇到的一些问题&lt;/p&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;用到的主键库是&lt;code&gt;iView&lt;/code&gt;组件库，跟&lt;code&gt;elementui	&lt;/code&gt;的组件差别不</summary>
      
    
    
    
    
    <category term="vue" scheme="https://coffepill.top/tags/vue/"/>
    
    <category term="iView" scheme="https://coffepill.top/tags/iView/"/>
    
  </entry>
  
  <entry>
    <title>axios请求实现同步-vue</title>
    <link href="https://coffepill.top/post/1a0d0418.html"/>
    <id>https://coffepill.top/post/1a0d0418.html</id>
    <published>2022-07-19T05:35:03.000Z</published>
    <updated>2022-07-19T07:16:14.383Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前axios异步请求导致我有时候只能在<code>then()</code>里把所有有关操作写完，这样代码就很不优雅，没办法封装，就研究了一下怎么实现同步，主要就是用<code>async</code>和<code>await</code>实现</p></blockquote><h4 id="第一种-直接调用axios"><a href="#第一种-直接调用axios" class="headerlink" title="第一种-直接调用axios"></a>第一种-直接调用<code>axios</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">await</span> axios.<span class="title function_">get</span>(url,params);<span class="comment">//直接将方法声明为async,在调用异步操作时加上await</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="第二种-封装axios请求在其他方法中调用"><a href="#第二种-封装axios请求在其他方法中调用" class="headerlink" title="第二种-封装axios请求在其他方法中调用"></a>第二种-封装axios请求在其他方法中调用</h4><p>封装的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">getApi</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//这是个国外免费测试接口</span></span><br><span class="line">     <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&quot;https://reqres.in/api/users?page=2&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resData</span>=res;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他方法中调用，在其他方法中调用也需要将该方法用<code>async</code>修饰并在调用方法时加上<code>await</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">other</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getApi</span>()</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;更新前&quot;</span>+<span class="variable language_">this</span>.<span class="property">resData</span>)</span><br><span class="line">      <span class="variable language_">this</span>.$nextTick().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">resData</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;之前axios异步请求导致我有时候只能在&lt;code&gt;then()&lt;/code&gt;里把所有有关操作写完，这样代码就很不优雅，没办法封装，就研究了一下怎么实现同步，主要就是用&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;await&lt;/code&gt;实现&lt;</summary>
      
    
    
    
    <category term="vue技巧" scheme="https://coffepill.top/categories/vue%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="axois" scheme="https://coffepill.top/tags/axois/"/>
    
    <category term="vue" scheme="https://coffepill.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue各种组件间传值方法整理</title>
    <link href="https://coffepill.top/post/231a815e.html"/>
    <id>https://coffepill.top/post/231a815e.html</id>
    <published>2022-07-14T07:05:01.000Z</published>
    <updated>2022-09-19T16:42:52.860Z</updated>
    
    <content type="html"><![CDATA[<div class="note primary simple"><p><strong>原本只是想了解一下除了正常的组件外的一些的方法，没想到在看官方文档时还发现平时许多没有注意到的传值细节</strong></p></div><h2 id="正常的父传子-props-，子传父-emit-，子传子"><a href="#正常的父传子-props-，子传父-emit-，子传子" class="headerlink" title="正常的父传子(props)，子传父($emit)，子传子"></a>正常的父传子(props)，子传父($emit)，子传子</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p><strong>父组件</strong></p><p>调用子组件时，绑定变量传入父组件的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                   &lt;!--子组件,并且在数据模型中定义propC ,msg是父组件定义的值,如果传入的是静态的值则可以不用:--&gt;</span><br><span class="line">                    &lt;transacDet :propC = &#x27;msg&#x27; /&gt;    </span><br><span class="line">                &lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><div class="note info simple"><p>包含该 prop 没有值的情况在内，都意味着 <code>true</code>。</p><p>如果没有在 props 中把 is-published 的类型设置为 Boolean，则这里的值为空字符串，而不是“true”。如果静态变量填的是false也需要加入v-bind绑定，使js认为这是个布尔类型而不是字符串</p><p>数组，对象，原型都需要v-bind绑定</p></div><p><strong>子组件</strong></p><p>在<code>props</code>中接收<code>parentMsg</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">//有多种定义方式</span></span><br><span class="line">     <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 值会通过任何类型验证)</span></span><br><span class="line">    <span class="comment">//propA: Number,</span></span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    <span class="comment">//propB: [String, Number],</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">propC</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,<span class="comment">// 必填的字符串</span></span><br><span class="line">      <span class="attr">default</span>: <span class="string">&quot;哈哈&quot;</span>   <span class="comment">// 带有默认值</span></span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    <span class="attr">propD</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组的默认值必须从一个工厂函数返回</span></span><br><span class="line">      <span class="title function_">default</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    <span class="attr">propE</span>: &#123;</span><br><span class="line">      <span class="title function_">validator</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个值必须与下列字符串中的其中一个相匹配</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;danger&#x27;</span>].<span class="title function_">includes</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 具有默认值的函数</span></span><br><span class="line">    <span class="attr">propG</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Function</span>,</span><br><span class="line">      <span class="comment">// 与对象或数组的默认值不同，这不是一个工厂函数——这是一个用作默认值的函数</span></span><br><span class="line">      <span class="title function_">default</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Default function&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> mounted () &#123;</span><br><span class="line"> <span class="comment">// 子组件通过props拿到父组件传来的数据,是个对象,直接this.propC可以使用数据</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;string==&#x27;</span>,<span class="variable language_">this</span>.<span class="property">propC</span>)  </span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><div class="note warning modern"><p><code>props</code>在传基本类型时是单向数据流，这时子组件对数据修改不会传递到父组件，但是当传递为<code>引用类型</code>时则父组件的数据也会发生改变，所以如果传递的是对象或者数组，要重新定义一个变量并进行深拷贝。</p></div><blockquote><p>补充：</p><ul><li>对象赋值：将一个对象赋值给一个新的对象的时候，赋的其实是该对象在栈中的地址，而不是堆中的数据。 也就是一个对象的改变就会改变另外一个对象。</li><li>浅拷贝：浅拷贝会创建一个对象，再去遍历原始对象，如果原对象的属性值是基础类型，那么就拷贝基础类型，如果是引用类型，则拷贝的是指针。</li><li>深拷贝：复制并创建一个一模一样的对象，不共享内存，修改新对象，旧对象保持不变。</li></ul></blockquote><hr><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><blockquote><p><code>$emit</code>方法有两个参数第一个是发出的方法名，第二个是发出的参数，当然也可以加N个参数除第一个是方法名外，后面的可以填写多个参数</p></blockquote><p><strong>子组件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;emitEvent&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&quot;我是子组件中的数据&quot;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">emitEvent</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.$emit(<span class="string">&#x27;my-event&#x27;</span>, <span class="variable language_">this</span>.<span class="property">msg</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//通过按钮的点击事件触发方法，然后用$emit触发一个my-event的自定义方法，传递this.msg数据。</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>父组件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-a</span> @<span class="attr">my-event</span>=<span class="string">&quot;getMyEvent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-a</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父组件中通过监测my-event事件执行一个方法，然后取到子组件中传递过来的值--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">ChildA</span> <span class="keyword">from</span> <span class="string">&#x27;./components/child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">ChildA</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">getMyEvent</span>(<span class="params">msg</span>)&#123;  <span class="comment">// msg是个形参value,实质是接收的子组件传来数据的参数</span></span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收的数据---------&gt;&#x27;</span>+msg)<span class="comment">//接收的数据---------&gt;我是子组件中的数据</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子传子"><a href="#子传子" class="headerlink" title="子传子"></a>子传子</h3><blockquote><p>　非父子组件之间传值，需要定义个公共的公共实例文件bus.js，作为中间仓库来传值，不然路由组件之间达不到传值的效果</p></blockquote><p><strong>第一步：新建个<code>bus.js</code>的文件,并在里面声明一个新的vue实例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//bus.js</span><br><span class="line"></span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default new Vue()</span><br></pre></td></tr></table></figure><p><strong>第二步</strong></p><p>对于要发出数据的组件A,通过调用bus的vue实例的方法$emit发出数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    A组件:</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;elementValue&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击触发&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;elementByValue&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 引入公共的bug，来做为中间传达的工具</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Bus</span> <span class="keyword">from</span> <span class="string">&#x27;./bus.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">elementValue</span>: <span class="number">4</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">elementByValue</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Bus</span>.$emit(<span class="string">&#x27;val&#x27;</span>, <span class="variable language_">this</span>.<span class="property">elementValue</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第三步</strong></p><p>对于要接收数据的组件B，通过bus的vue实例方法$on接收</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    B组件:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击触发&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;getData&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Bus</span> <span class="keyword">from</span> <span class="string">&#x27;./bus.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    data () &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">mounted</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> vm = <span class="variable language_">this</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 用$on事件来接收参数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Bus</span>.$on(<span class="string">&#x27;val&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span></span><br><span class="line"><span class="language-javascript">        vm.<span class="property">name</span> = data</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">getData</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">name</span>++</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="其他的传值方式"><a href="#其他的传值方式" class="headerlink" title="其他的传值方式"></a>其他的传值方式</h2><h3 id="父传子-1"><a href="#父传子-1" class="headerlink" title="父传子"></a>父传子</h3><h4 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h4><p>在子组件特定位置加入slot标签，在之后父组件在调用子组件时加入的字符串等数据替换到插槽所在位置，如;</p><p><strong>子组件</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--匿名插槽 每个组件只能有一个--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">solt</span>&gt;</span><span class="tag">&lt;/<span class="name">solt</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--具名插槽solt--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">solt</span> <span class="attr">name</span>=<span class="string">&quot;first&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">solt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>父组件:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--不指定solt发送就会发送到所有solt中--&gt;</span></span><br><span class="line">            不具名内容</span><br><span class="line">            <span class="comment">&lt;!--指定分发到name是first的solt中，有两种写法都可以--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--第一种--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">solt</span>=<span class="string">&quot;first&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--第二种--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:first</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>具名插槽在父组件未指定分配是不会被替换，如代码中的“不具名内容”就不会出现两次，他只会在匿名插槽中被渲染出来</p></blockquote><h4 id="refs"><a href="#refs" class="headerlink" title="$refs"></a>$refs</h4><p>通过$refs将父组件的值赋值给子组件的数据中，如：</p><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;open&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">msg</span>:<span class="string">&quot;123&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">open</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">child</span>.<span class="property">childMsg</span>=<span class="variable language_">this</span>.<span class="property">msg</span>;<span class="comment">//childMsg即是child组件的data的一个参数，当然也可以调用child的一个方法</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="children"><a href="#children" class="headerlink" title="$children"></a>$children</h4><p>他返回的是一个组件集合，如果你能清楚的知道子组件的顺序，你也可以使用下标来操作；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="variable language_">this</span>.<span class="property">$children</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$children</span>[i].<span class="property">children_data</span>);</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">$children</span>[i].<span class="title function_">children_fun</span>();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="子传父-1"><a href="#子传父-1" class="headerlink" title="子传父"></a>子传父</h3><h4 id="parent"><a href="#parent" class="headerlink" title="$parent"></a>$parent</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vue 里 this.$parent 作用</span><br><span class="line">$parent在子组件中调用父组件的方法或获得其数据</span><br><span class="line">this.$parent 可以访问到父组件上所有的 data()&#123; 里的数据信息和生命周期方法，methods里的方法 &#125;</span><br><span class="line"></span><br><span class="line">如 this.$parent.List = []; 表示访问到父组件中data的数据list数组</span><br><span class="line"></span><br><span class="line">区分</span><br><span class="line">1、ref为子组件指定一个索引名称，通过索引来操作子组件；</span><br><span class="line">2、this.$parent 可以直接访问该组件的父实例或组件；</span><br><span class="line">3、父组件也可以通过this.$children 访问它所有的子组件，</span><br><span class="line">$parent和$children 可以递归向上或向下无线访问， 直到根实例或最内层的组件。</span><br></pre></td></tr></table></figure><hr><h3 id="跨组件传值provide-x2F-inject"><a href="#跨组件传值provide-x2F-inject" class="headerlink" title="跨组件传值provide&#x2F;inject"></a>跨组件传值provide&#x2F;inject</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 祖先组件 提供foo</span></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;grandfather&quot;</span>,</span><br><span class="line">  <span class="title function_">provide</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attr">foo</span>:<span class="string">&#x27;halo&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;grandfather&quot;</span>,</span><br><span class="line">  <span class="attr">provide</span>:&#123;</span><br><span class="line">    <span class="attr">foo</span>:<span class="string">&#x27;halo~~~~&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后代组件 注入foo</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>:[<span class="string">&#x27;foo&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你只是传一个字符串，像上面的‘halo’，那么是没有区别的，后代都能读到。<br>如果你需要传一个对象（如下所示代码），那么第二种是传不了的，后代组件拿不到数据。所以建议只写第一种</p><p>一旦注入了某个数据，比如上面示例中的 foo，那这个组件中就不能再声明 foo 这个数据了，因为它已经被父级占有。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/huoshengmiao/p/15236699.html">vue中父子传值及vue中$refs、$emit、$on、$parent、$children使用的理解 - Jim-vue - 博客园 (cnblogs.com)</a></p><p><a href="https://v3.cn.vuejs.org/guide/component-props.html#prop-%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E5%91%BD%E5%90%8D-camelcase-vs-kebab-case">Props | Vue.js (vuejs.org)</a></p><p><a href="https://juejin.cn/post/6844903833898844174#heading-1">vue组件封装指南 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note primary simple&quot;&gt;&lt;p&gt;&lt;strong&gt;原本只是想了解一下除了正常的组件外的一些的方法，没想到在看官方文档时还发现平时许多没有注意到的传值细节&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;正常的父传子-props-，子</summary>
      
    
    
    
    <category term="知识点整理" scheme="https://coffepill.top/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
    <category term="vue" scheme="https://coffepill.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>html/css/js基础篇（错题笔记）</title>
    <link href="https://coffepill.top/post/5f8f8107.html"/>
    <id>https://coffepill.top/post/5f8f8107.html</id>
    <published>2022-07-13T01:57:09.000Z</published>
    <updated>2022-09-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="“table”"><a href="#“table”" class="headerlink" title="“table”"></a>“table”</h3><p>标签设置标题：加入“caption”标签</p><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>项目名<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>项目内容<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="音频-x2F-视频标签"><a href="#音频-x2F-视频标签" class="headerlink" title="音频&#x2F;视频标签"></a>音频&#x2F;视频标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--controls显示控件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;source&gt; 标签为媒介元素（比如 &lt;video&gt; 和 &lt;audio&gt;）定义媒介资源标签允许您规定可替换的视频/音频文件供浏览器根据它对媒体类型或者编解码器的支持进行选择。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span><span class="comment">&lt;!--音频 controls:显示控件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">onerror</span>=<span class="string">&quot;myFunction&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span><span class="comment">&lt;!--视频 onerror执行错误事件--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="获取用户当前位置"><a href="#获取用户当前位置" class="headerlink" title="获取用户当前位置"></a>获取用户当前位置</h3><p>“navigator.geolocation”对象提供了可以公开访问地理位置的方法，其中navigator为浏览器内置对象，对于移动Web开发者，大多数情况只需要获取用户的当前位置，此时我们可以使用getCurrentPosition()方法来获取当前位置的坐标值。</p><p>当信息获取到之后会在回调函数中传入position对象。</p><p>position对象包含两个属性，一个是coords(坐标)，它是一个Coordiante对象，包含当前位置信息;另一个是timestamp，表示获取到位置的时间戳。</p><p>coordiante对象包含包括经纬度在内的一系列信息具体如下所示。</p><p>latitude：一个十进制表示的纬度坐标。</p><p>longitude：一个十进制表示经度的坐标。</p><p>altitude：海拔高度(以米为单位，如果是5，表示精确到5米范围)。</p><p>accuracy：当前经纬度信息的精度(以米为单位)。</p><p>altitudeAccuracy：当前海拔高度的精度。</p><p>heading：代表当前设备的朝向，该值是以弧度为单位，指示了按顺时针方向相对</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">function</span> <span class="title function_">getMyPosition</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">geolocation</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//获取当前位置..</span></span></span><br><span class="line"><span class="language-javascript">               <span class="title function_">alert</span>(<span class="string">&quot;正在获取您的位置.&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//如果获取位置成功，会调用名字为successPosition 的方法.</span></span></span><br><span class="line"><span class="language-javascript">               navigator.<span class="property">geolocation</span>.<span class="property">getCurrentPosition</span></span></span><br><span class="line"><span class="language-javascript">               (successPosition,errorPosition);</span></span><br><span class="line"><span class="language-javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="title function_">alert</span>(<span class="string">&quot;您当前的浏览器不支持..&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">function</span> <span class="title function_">successPosition</span>(<span class="params">position</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">var</span> jd=position.<span class="property">coords</span>.<span class="property">longitude</span>;<span class="comment">//经度</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">var</span> wd=position.<span class="property">coords</span>.<span class="property">latitude</span>;<span class="comment">//纬度</span></span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(jd+<span class="string">&quot;,&quot;</span>+wd);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//如果没有获取到位置，就会调用这个方法</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">errorPosition</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&quot;获取位置失败.&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">getMyPosition</span>();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="由-SVG-定义的图形是什么格式的？"><a href="#由-SVG-定义的图形是什么格式的？" class="headerlink" title="由 SVG 定义的图形是什么格式的？"></a>由 SVG 定义的图形是什么格式的？</h3><p><code>XML</code></p><h3 id="lt-meter-gt-标签定义度量衡。仅用于已知最大和最小值的度量"><a href="#lt-meter-gt-标签定义度量衡。仅用于已知最大和最小值的度量" class="headerlink" title="&lt;meter&gt; 标签定义度量衡。仅用于已知最大和最小值的度量"></a><code>&lt;meter&gt;</code> 标签定义度量衡。仅用于已知最大和最小值的度量</h3><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="nth-child"><a href="#nth-child" class="headerlink" title="nth-child()"></a>nth-child()</h3><p>在css中可以通过伪类选择器:nth-child(n)匹配属于其父元素的第n个子元素，不论元素类型，n可以是数字、关键词、或公式。</p><blockquote><p>关键词<code>odd</code>和<code>even</code>是可用于匹配下标是奇数或偶数的子元素的关键词（第一个子元素的下标是 1）。</p></blockquote><h3 id="after伪类"><a href="#after伪类" class="headerlink" title="::after伪类"></a>::after伪类</h3><p>默认为行内元素，需要设置宽高时要改为块元素</p><h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><p>**<code>em</code>**：它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em &#x3D;&#x3D; 32px；</p><p><strong><code>rem</code></strong>: rem 是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小。</p><p><strong><code>vmax/vmin</code></strong>:<code>vh</code>和<code>vw</code>中较大&#x2F;小的那个；</p><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h3 id="数组排序方法sort"><a href="#数组排序方法sort" class="headerlink" title="数组排序方法sort()"></a>数组排序方法sort()</h3><p>使用的是冒泡排序，默认字母排序，如果要根据数字排序就需要加入参数function(a,b),a和b表示数组中前后相邻的两个数字，function返回值为正数时交换a,b位置</p><h3 id="字符串大小写"><a href="#字符串大小写" class="headerlink" title="字符串大小写"></a>字符串大小写</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>toLowerCase()</td><td>字符串改小写</td></tr><tr><td>toUpperCase()</td><td>字符串改大写</td></tr></tbody></table><blockquote><p>实现字符串首字母大写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=string[<span class="number">0</span>].<span class="title function_">toUpperCase</span>()+string.<span class="title function_">substr</span>(<span class="number">1</span>).<span class="title function_">toLowerCase</span>()</span><br></pre></td></tr></table></figure></blockquote><h3 id="Object的一些方法"><a href="#Object的一些方法" class="headerlink" title="Object的一些方法"></a>Object的一些方法</h3><table><thead><tr><th align="center">方法</th><th>作用</th></tr></thead><tbody><tr><td align="center">Object.keys()</td><td>方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。</td></tr><tr><td align="center">Object.values()</td><td>方法返回一个给定对象自身的所有可枚举属性值的数组。</td></tr></tbody></table><h3 id="去除字符串空格"><a href="#去除字符串空格" class="headerlink" title="去除字符串空格"></a>去除字符串空格</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="title function_">replace</span>(<span class="regexp">/^\s+|\s+$/gm</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">x.<span class="title function_">trim</span>();</span><br><span class="line"><span class="comment">//不会改变原数组</span></span><br></pre></td></tr></table></figure><h3 id="给一时间戳，返回对应日期"><a href="#给一时间戳，返回对应日期" class="headerlink" title="给一时间戳，返回对应日期"></a>给一时间戳，返回对应日期</h3><h4 id="用原始方法不借用现成date函数"><a href="#用原始方法不借用现成date函数" class="headerlink" title="用原始方法不借用现成date函数"></a>用原始方法不借用现成date函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function _date(number)&#123;</span><br><span class="line">    //不要投机取巧,要靠自己的实力!</span><br><span class="line">    </span><br><span class="line">//1天=24小时=24*60分钟=24*60*60秒=24*60*60*1000毫秒</span><br><span class="line">let msInDay=24*60*60*1000;//一天有多少毫秒</span><br><span class="line">let days=Math.floor(number/msInDay);//这些毫秒等于多少天</span><br><span class="line">//从计算机元年算起</span><br><span class="line">    let year=1970;</span><br><span class="line">let month=1;</span><br><span class="line">let date=1;</span><br><span class="line">//循环:用天数计算月日</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        //判断闰年,计算2月的天数</span><br><span class="line">let february=year%4==0&amp;&amp;year%100!==0||year%400==0?29:28;</span><br><span class="line">//     月份表     1     2     3  4  5  6  7  8  9 10 11 12</span><br><span class="line">let daysInMonth=[31,february,31,30,31,30,31,31,30,31,30,31];</span><br><span class="line">let currentDaysInMonth=daysInMonth[month-1];//获取当月的天数</span><br><span class="line">//剩余天数够不够当月</span><br><span class="line">        if(days&gt;currentDaysInMonth)&#123;</span><br><span class="line">//如果够,就做减</span><br><span class="line">            days-=currentDaysInMonth;</span><br><span class="line">month++;//增加月数</span><br><span class="line">&#125;else&#123;</span><br><span class="line">            //否则就追加到日数</span><br><span class="line">date+=days;</span><br><span class="line">//到这时,就计算完成了</span><br><span class="line">            return `$&#123;year&#125;-$&#123;month&#125;-$&#123;date&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">        //当月数大于12时,就说明本年已完结</span><br><span class="line">if(month&gt;12)&#123;</span><br><span class="line">month=1;//月数归1</span><br><span class="line">year++;//年份增加</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用date函数实现"><a href="#调用date函数实现" class="headerlink" title="调用date函数实现"></a>调用date函数实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function _date(number) &#123;</span><br><span class="line">    // 补全代码</span><br><span class="line">    let date = new Date(number);</span><br><span class="line">    return `$&#123;date.getFullYear()&#125;-$&#123;date.getMonth()+1&#125;-$&#123;date.getDate()&#125;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上文中返回的是一个模板字符串，模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在 <code>ES6</code>规范的先前版本中被称为“模板字符串”。模板字符串使用反引号 (<code> </code>) 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（<code>$&#123;expression&#125;</code>）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（&#96;）时，需要在它前面加转义符（\）。</p></blockquote><h3 id="小数取整"><a href="#小数取整" class="headerlink" title="小数取整"></a>小数取整</h3><p><strong>位运算</strong></p><p>位运算返回的是一个整数，所以可以通过位运算左移或右移0位实现取整操作</p><p><strong>parseInt(value)</strong></p><p><strong>Math方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Math.floor(value)  向下取一个整数</span></span><br><span class="line"><span class="comment">// Math.cell(value)  向上取整</span></span><br><span class="line"><span class="comment">// Math.round(value) 返回一个四舍五入的值</span></span><br><span class="line"><span class="comment">// Math.trunc(value) 直接去除小数点后面的值</span></span><br></pre></td></tr></table></figure><h3 id="如何在浏览器的状态栏放入一条消息？"><a href="#如何在浏览器的状态栏放入一条消息？" class="headerlink" title="如何在浏览器的状态栏放入一条消息？"></a>如何在浏览器的状态栏放入一条消息？</h3><p>JavaScript的Windows对象有一个status 属性可设置或返回窗口状态栏中的文本。</p><p>语法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">status</span> = <span class="string">&quot;put your message here&quot;</span></span><br></pre></td></tr></table></figure><h3 id="解决settimeout内部this指向window的三种解决方案"><a href="#解决settimeout内部this指向window的三种解决方案" class="headerlink" title="解决settimeout内部this指向window的三种解决方案"></a>解决settimeout内部this指向window的三种解决方案</h3><p>1.保存外部this</p><p>2.apply，call，bind绑定</p><p>3.箭头函数</p><h3 id="call的参数为null时相当于没有参数"><a href="#call的参数为null时相当于没有参数" class="headerlink" title="call的参数为null时相当于没有参数"></a>call的参数为null时相当于没有参数</h3><h3 id="会引起重绘的操作有这些"><a href="#会引起重绘的操作有这些" class="headerlink" title="会引起重绘的操作有这些"></a>会引起重绘的操作有这些</h3><p>1.访问offset,client,scroll等相关属性</p><p>2.元素大小发生改变</p><p>3.窗口大小发生改变</p><p>4.浏览器刷新</p><p>5.元素通过display改变了可视性</p><p>6.元素定位发生改变</p><p>7.元素的font-size发生改变</p><p>8.元素的伪类触发</p><h3 id="可迭代内置对象"><a href="#可迭代内置对象" class="headerlink" title="可迭代内置对象"></a>可迭代内置对象</h3><p>String，Array，typedArray,Map,Set</p><h3 id="立即执行函数问题"><a href="#立即执行函数问题" class="headerlink" title="立即执行函数问题"></a>立即执行函数问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params">foo</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">n</span>);</span><br><span class="line">    foo.<span class="property">n</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">n</span>);</span><br><span class="line">&#125;)(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">n</span>);</span><br></pre></td></tr></table></figure><blockquote><p>1，2，3</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; </span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a = <span class="number">20</span>;<span class="comment">//立即执行函数内与函数名同名的变量不可修改</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//输出函数体</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="加法问题"><a href="#加法问题" class="headerlink" title="加法问题"></a>加法问题</h3><p>此题在计算时要先计算<code>+ +“2”</code>会等于数字2之后再计算1+2&#x3D;3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>+ +<span class="string">&quot;2&quot;</span>)<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>这里的计算方式是加数组内元素，如<code>+[2]=2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+[]<span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>数组相加会转化为字符串相加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]+[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]<span class="comment">//&quot;1,2,34,5,6&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span>+<span class="number">0.2</span>！=<span class="number">0.3</span></span><br><span class="line"><span class="number">0.1</span>+<span class="number">0.7</span>！=<span class="number">0.8</span></span><br><span class="line"><span class="number">0.2</span>+<span class="number">0.4</span>=<span class="number">0.6000000000000001</span></span><br><span class="line"><span class="number">0.2</span>+<span class="number">0.7</span>=<span class="number">0.8999999999999999</span></span><br><span class="line"><span class="number">0.3</span>+<span class="number">0.6</span>=<span class="number">0.8999999999999999</span></span><br><span class="line"><span class="number">0.4</span>+<span class="number">0.8</span>=<span class="number">1.2000000000000002</span></span><br><span class="line"><span class="number">0.6</span>+<span class="number">0.7</span>=<span class="number">1.2999999999999998</span></span><br><span class="line"><span class="number">0.8</span>+<span class="number">0.9</span>=<span class="number">1.7000000000000002</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有0.2-0.1==0.1，其余关于减法得数为0.1的都会为false，如0.4-0.3=0.10000000000000003</span></span><br><span class="line"><span class="comment">//0.6-0.(2n)都不会得到响应的数</span></span><br><span class="line"><span class="comment">//0.7减n(0.1&lt;n&lt;=0.6)得数都不对</span></span><br><span class="line"><span class="comment">//0.8减[0.1,0.2,[0.5-0.7]]得数都不对</span></span><br><span class="line"><span class="comment">//0.9减[0.3,0.6,0.7,0.8]得数都不正确</span></span><br></pre></td></tr></table></figure><h3 id="js对象分类"><a href="#js对象分类" class="headerlink" title="js对象分类"></a>js对象分类</h3><p>对象分为三类： 内置对象       宿主对象         自定义对象</p><p>（1）内置对象：  Arguments   Array  Boolean  Date  Error  Function  Number  String  Regexp  Math  Object</p><p>（2）宿主对象：运行环境提供的对象。如Window和Documen，Element，form，image。</p><p>（3）自定义对象：开发人员定义的对象。</p><h3 id="class-static"><a href="#class-static" class="headerlink" title="class static"></a>class static</h3><p>静态方法本身不能使用实例对象来调用，静态方法只能由类进行调用，实例方法只能由实例对象进行调用，由于类内部的静态方法的调用者只能为类，实例方法的调用者只能为实例对象，不会在调用时造成歧义，因此允许重名。</p><h3 id="readOnly与disbled"><a href="#readOnly与disbled" class="headerlink" title="readOnly与disbled"></a>readOnly与disbled</h3><p>disabled和readOnly都是表单的公有属性， readOnly是只读， disabled是禁用。</p><p>Readonly 只针对 input(text&#x2F;password) 和 textarea 有效</p><p>只要设置了 [disabled] 属性不论什么值都会禁用,包括 <strong>false</strong>,页面似乎只在乎是否有这个属性 而不在乎其值</p><p>即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;button1&quot;</span>).<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;button1&quot;</span>).<span class="property">disabled</span> = <span class="literal">false</span>;<span class="comment">//可以改回成可用状态</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;button1&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;disabled&#x27;</span>,<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;button1&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;disabled&#x27;</span>,<span class="string">&#x27;false&#x27;</span>);<span class="comment">//修改无效</span></span><br></pre></td></tr></table></figure><h3 id="event-shiftKey"><a href="#event-shiftKey" class="headerlink" title="event.shiftKey"></a>event.shiftKey</h3><p>按下shift键时，在<code>onkeydown</code>中<code>event.shiftKey</code>等于<code>true</code>,但是在<code>onkeyup</code>中则为<code>false</code>,<code>shiftKey</code>是用来判断shift是否被按下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h2&gt;&lt;h3 id=&quot;“table”&quot;&gt;&lt;a href=&quot;#“table”&quot; class=&quot;headerlink&quot; title=&quot;“ta</summary>
      
    
    
    
    <category term="错题笔记" scheme="https://coffepill.top/categories/%E9%94%99%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="css" scheme="https://coffepill.top/tags/css/"/>
    
    <category term="js" scheme="https://coffepill.top/tags/js/"/>
    
    <category term="HTML" scheme="https://coffepill.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>前端笔记（持续更新）</title>
    <link href="https://coffepill.top/post/f4b15d3f.html"/>
    <id>https://coffepill.top/post/f4b15d3f.html</id>
    <published>2022-07-12T01:16:29.000Z</published>
    <updated>2022-07-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info simple"><p>记录一些平时看到的知识点，没有顺序整理。</p></div><hr><h2 id="专业名词"><a href="#专业名词" class="headerlink" title="专业名词"></a>专业名词</h2><h3 id="SPA单页面项目"><a href="#SPA单页面项目" class="headerlink" title="SPA单页面项目"></a>SPA单页面项目</h3><ul><li><p>概念：<strong>SPA</strong>（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS实现页面的渲染加载。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互、避免页面的重新加载。</p></li><li><p>优点：</p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>SPA 相对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul></li><li><p>缺点：</p><ul><li><strong>初次加载耗时多</strong>：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载</li><li><strong>前进后退路由管理</strong>：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li><strong>SEO 难度较大</strong>：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><blockquote><p>SEO： Search Engine Optimization, 搜索引擎优化。利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益。</p></blockquote></li><li><p>劣势解决:</p><ul><li><p>劣势解决</p><blockquote><p>SPA单页面应用：在使用ajax与服务器数据交互过程中，实现局部数据的更新时，浏览器地址栏的url链接并没有发生改变，浏览器因为不会保存更新记录（浏览器会记录地址栏的url资源链接，如果url链接发生变化，浏览器会把该url链接保存到一个特殊的数据结构中，这样当用户点击返回与前进按钮时，会快速访问已经被记录的url链接资源。）。这时候再去返回就会出现非期待性的结果</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 解决方案：设置window.location.hash（location.hash）+ 监听window.onhashchange</span><br></pre></td></tr></table></figure><blockquote><p>第二种解决方法是在页面中嵌入一个隐藏 iframe，由于浏览器可以对 DOM 树中 iframe 节点的 src 属性进行历史记录跟踪，这样通过在逻辑上建立一条“页面 URL – 页面内 iframe URL – 页面状态”的对应链，同样可以在 IE 中建立片段标识符与页面状态的联系。</p></blockquote></li></ul></li></ul><h4 id="…args剩余参数-扩展运算符"><a href="#…args剩余参数-扩展运算符" class="headerlink" title="…args剩余参数(扩展运算符)"></a>…args剩余参数(扩展运算符)</h4><p><strong>展开运算</strong>：允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。</p><p><strong>剩余参数</strong>：剩余参数语法允许我们将一个不定数量的参数表示为一个数组。</p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>200 成功状态码<br>202服务器已经接收到请求数据，但尚未进行处理<br>206 发送范围请求头Range抓取到资源的部分内容（大文件下载、分割多个部分同时下载等）<br>301 永久重定向（永久移动）<br>302 暂时重定向（临时移动）<br>304协商缓存（请求的资源未修改）<br>307临时重定向<br>400服务端无法理解（客户端语法错误）<br>401用户需要验证<br>403请求已成功，但被拒绝<br>404找不到资源,请求资源不存在<br>500服务器内部错误<br>505服务器不支持请求的HTTP协议版本</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="使一个div元素居中在页面中央"><a href="#使一个div元素居中在页面中央" class="headerlink" title="使一个div元素居中在页面中央"></a>使一个div元素居中在页面中央</h3><p>居中用绝对定位或者固定定位当前页面下，操作方法一样。</p><p>下面以绝对定位来写：</p><div class="tabs" id="居中"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#居中-1"><i class="fas"></i>方法一</button></li><li class="tab"><button type="button" data-href="#居中-2"><i class="fas"></i>方法二</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="居中-1"><p>将div的定位放在屏幕50%的地方，但是这只是把div的左上角放在中央，之后就需要借助<code>transform</code>调整div位置，<code>transform</code>第一个参数调整X轴，第二个参数调整Y轴</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center-in-center</span> &#123;</span><br><span class="line">                <span class="attribute">position</span>: absolute;</span><br><span class="line">                <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">                <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">                -webkit-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">                -moz-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">                -ms-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">                -o-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">                <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="居中-2"><p>上下左右的距离都设为0，然后设置外边距<code>margin:auto</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line"> <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="消除浮动"><a href="#消除浮动" class="headerlink" title="消除浮动"></a>消除浮动</h3><div class="tabs" id="消除浮动"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#消除浮动-1"><i class="fas"></i>方法一 BFC</button></li><li class="tab"><button type="button" data-href="#消除浮动-2"><i class="fas"></i>方法二 zoom</button></li><li class="tab"><button type="button" data-href="#消除浮动-3"><i class="fas"></i>方法三 clear：both</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="消除浮动-1"><p>父元素开启BFC</p><p>父元素加<code>overflow：hidden</code>属性，没设置高度则会自适应浮动元素高度</p><blockquote><p>不能和定位一起用，超出部分会隐藏</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="消除浮动-2"><p>是在父元素中加个<code>clearfloat{zoom：1}</code>属性类</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="消除浮动-3"><blockquote><p>在父元素后加after伪类</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="普通阴影"><a href="#普通阴影" class="headerlink" title="普通阴影"></a>普通阴影</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">box-shadow:0px</span> <span class="string">0px</span> <span class="string">10px</span> <span class="string">0px</span> <span class="comment">#ccc;</span></span><br></pre></td></tr></table></figure><h3 id="背景颜色渐变"><a href="#背景颜色渐变" class="headerlink" title="背景颜色渐变"></a><strong>背景颜色渐变</strong></h3><p><code>background-image: linear-gradient( 角度 , 颜色);</code></p><blockquote><p><strong>linear</strong>代表线性渐变；<strong>radial</strong>代表中心扩散;</p><p>颜色可以添加多个，会自动分配；不填方向角度就会从中间向外扩散；利用at可以设置扩散中心</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(circle at <span class="number">20%</span> <span class="number">20%</span>, <span class="number">#99CCCC</span>, <span class="number">#7171B7</span>);</span><br></pre></td></tr></table></figure><h3 id="背景容器磨砂质感实现"><a href="#背景容器磨砂质感实现" class="headerlink" title="背景容器磨砂质感实现"></a>背景容器磨砂质感实现</h3><p>在容器的样式中增加高斯模糊和背景颜色半透明，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">backdrop-<span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">15px</span>); </span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.1</span>);</span><br></pre></td></tr></table></figure><h3 id="样式覆盖问题"><a href="#样式覆盖问题" class="headerlink" title="样式覆盖问题"></a>样式覆盖问题</h3><p>直接指定的样式发生冲突时，样式权值高者获胜。</p><p><img src="/post/f4b15d3f/Image.png"></p><p>可以看到，内联样式的权值&gt;&gt;ID选择器&gt;&gt;类选择器&gt;&gt;标签选择器，除此以外，后代选择器的权值为每项权值之和，比如”#id .class a”的权值为100 + 10 + 1 &#x3D; 111。</p><h3 id="after于-after的区别"><a href="#after于-after的区别" class="headerlink" title=":after于::after的区别"></a>:after于::after的区别</h3><p><code>::after</code>是伪元素，<code>:after</code>是伪类，<code>::after</code>是出现在css3中，是为了与伪类（:hover等）做区分才出现的。大部分情况下两者使用上没有区别，但是在IE8版本会有不兼容问题。</p><h3 id="css一些属性的理解"><a href="#css一些属性的理解" class="headerlink" title="css一些属性的理解"></a>css一些属性的理解</h3><p>**<code>line-height</code>**：行高可以理解为行间距<br>**<code>Zoom</code>**属性是IE浏览器的专有属性， 它可以设置或检索对象的缩放比例。在平常的css编写过程中，<code>zoom:1</code>能够比较神奇地解决ie下比较奇葩的bug。譬如外边距（margin）的重叠，譬如浮动的清除，譬如触发ie的 haslayout属性等等。</p><p><strong><code>transform</code></strong>: 允许你旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。tip: 只能转换由盒模型定位的元素。根据经验，如果元素具有display: block，则由盒模型定位元素。transform会直接改变元素原本的形态，不会是动态改变的效果。所以还需要加入<strong>transition</strong>过渡属性配合使用实现动态转换的效果。</p><p><strong><code>vertical-align</code></strong> 属性设置元素的垂直对齐方式。</p><blockquote><p><strong>设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</strong></p></blockquote><p> **<code>cursor: pointer;</code>**该属性可以改变鼠标悬停时的格式</p><hr><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="刷新页面后页面滚动回到顶部"><a href="#刷新页面后页面滚动回到顶部" class="headerlink" title="刷新页面后页面滚动回到顶部"></a><strong>刷新页面后页面滚动回到顶部</strong></h3><p>使用很简单，在页面的任意位置执行下面几行 JS 代码就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(history.<span class="property">scrollRestoration</span>) &#123;</span><br><span class="line">    history.<span class="property">scrollRestoration</span> = <span class="string">&#x27;manual&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>history.scrollRestoration</code>支持下面两个属性值：<strong>auto</strong>默认值，表示滚动位置会被存储。<strong>manual</strong>单词的意思就是手动。表示，滚动的位置不会被存储。</p><p>直接使用使用<code>stop()</code>方法，则会立即停止<strong>当前</strong>正在进行的动画，如果接下来还有动画等待继续进行，则以当前状态开始接下来的动画。</p><h3 id="BOM浏览器对象模型"><a href="#BOM浏览器对象模型" class="headerlink" title="BOM浏览器对象模型"></a>BOM浏览器对象模型</h3><h4 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h4><ul><li><p>概念：BOM的核心对象是window，它表示浏览器的一个实例，它也是ECMAScript规定的Globle对象，也就是说网页中任何一个对象都是在window这个对象里面的</p><blockquote><ul><li>alert()</li><li>confirm()</li><li>prompt()</li><li>setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</li><li>setTimeout() ：在指定的毫秒数后调用函数或计算表达式。</li></ul></blockquote></li></ul><h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><ul><li><p>概念： location属性用于获得当前窗口中加载的文档有关的信息或者设置窗体的URL，并且可以解析URL，因为返回的是一个对象，因此可以叫做location对象，还有一些导航功能，值得注意的是location既是window对象的属性，又是document对象的属性，既window.location和document.location 引用的是同一个对象。</p><blockquote><p>location.href &#x3D; “<a href="http://www.666.com”/">http://www.666.com”</a>; &#x2F;&#x2F;页面跳转到该网址<br>location.assign(“<a href="http://www.666.com”/">http://www.666.com”</a>); &#x2F;&#x2F;页面跳转到该网址<br>location.hash用于设置页面的标签值</p></blockquote></li></ul><h4 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h4><ul><li><p>概念：该对象里面保存着浏览器的各种信息，判断浏览器的各种信息就是从该对象里的属性来读取</p><blockquote><p>navigator.cookicEnablcd:判断是否启用cookic<br>navigator.userAgent:判断浏览器的名称和版本号<br>navigator.plugins:保存浏览器中所有插件信息的集合</p><p>“navigator.geolocation”对象提供了可以公开访问地理位置的方法，我们可以使用getCurrentPosition()方法来获取当前位置的坐标值</p></blockquote></li></ul><h4 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h4><ul><li><p>概念：该对象保存着用户上网的历史记录，从窗口被打开的那一刻算起</p><blockquote><p>1.前进：history.forward();history.go(1);<br>2.后退：history.back();history.go(-1);<br>3.获取记录个数：history.length:</p></blockquote></li></ul><h3 id="数组中的一些方法"><a href="#数组中的一些方法" class="headerlink" title="数组中的一些方法"></a>数组中的一些方法</h3><p><img src="/post/f4b15d3f/2.png"></p><p><a href="https://www.jianshu.com/p/7e160067a06c?u_atoken=cba79251-df9f-48b7-800a-7de6578b7b1c&u_asession=0173dhDNyWGgtn7jgGUrT8KBN6YYoFnX7PuRKYrb5OnTAj6UGeBTkZWqe9NRPr8RgsX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K_fRKv8lUifIC8Nb6j1ZnUJMKWrbBzYAhXhkL4v5_cjQmBkFo3NEHBv0PZUm6pbxQU&u_asig=053WpEGOMjJshjOP0P2n9LKw5sQIyDmQYY4U5ayH4V1ZfsU8hiUEoXclK-qNWXVQF6DBIlhvwcyKdImiA3tlU78yp7z66G8XErKHvmsoZ-1Rgw4ozCvAeicNSUUwW897-uJ1rrdWg-6h89hqWHizDNBf0JyRkDMkVPVFrbBmZ9ikz9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzee-nFoyjTWgTfL0PJrnnS3Fn5DeYSAKDxLj4EGnKz2Gdf9JIAkyKervFWgmMgV8j-3h9VXwMyh6PgyDIVSG1W_MxoMRa1ot469tjiOOwaBeZ7OcBSWDdwssbaPOg4AdDQ8bZ2ZTyK3dlETgdQQdrFmXalb3n0P_xD-wGuZJNOxXmWspDxyAEEo4kbsryBKb9Q&u_aref=xhFLBERac8QqBfFjx+P3X7F8Szw=">JavaScript数组（Array）方法大全 - 简书 (jianshu.com)</a></p><h3 id="JS数据类型-x2F-数据结构"><a href="#JS数据类型-x2F-数据结构" class="headerlink" title="JS数据类型&#x2F;数据结构"></a>JS数据类型&#x2F;数据结构</h3><p><strong>基本数据类型</strong>（简单数据类型）7种：number，string，boolean,null,undefined，symbol，bigInt</p><blockquote><p>symbol是一个<a href="https://so.csdn.net/so/search?q=ES6&spm=1001.2101.3001.7020">ES6</a>标准种新增的一种基本数据类型,symbol 的值是通过 Symbol() 函数生成，每一个 symbol 的值都是唯一的，并且 symbol 类型的值可以作为对象的属性<a href="https://so.csdn.net/so/search?q=%E6%A0%87%E8%AF%86%E7%AC%A6&spm=1001.2101.3001.7020">标识符</a>使用，这也是 symbol 类型设计的目的。</p></blockquote><p><strong>复杂数据类型</strong>：array，function，object</p><h3 id="对象和数组有什么区别"><a href="#对象和数组有什么区别" class="headerlink" title="对象和数组有什么区别"></a>对象和数组有什么区别</h3><p>1.数组表示有序数据的集合，而对象表示无序数据的集合。如果数据的顺序很重要，就用数组，否则就用对象</p><p>2.数组是种有顺序的链表，对象是无顺序的键值对。</p><p>3.数组有length属性，对象没有</p><h4 id="如何判断什么是一个对象和数组"><a href="#如何判断什么是一个对象和数组" class="headerlink" title="如何判断什么是一个对象和数组"></a><strong>如何判断什么是一个对象和数组</strong></h4><p>1.instanceof</p><p>instanceof运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>;<span class="comment">//true 实例obj在不在Object构造函数中</span></span><br></pre></td></tr></table></figure><p>2.对象的constructor属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,1];</span><br><span class="line">var obj = &#123;</span><br><span class="line">a:“A”,</span><br><span class="line">c:“C”</span><br><span class="line">&#125;</span><br><span class="line">　console.log(arr.constructor === Array)//true</span><br><span class="line">　console.log(obj.constructor === Object) //true</span><br></pre></td></tr></table></figure><p>3.Array.isArray([]) &#x2F;&#x2F;true ES6语法<br>4.Object.prototype.toString.call(arr) 利用对象的toString可以准确判断是什么类型，call()改变this指向，这里是借用Object的方法</p><hr><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="阻止网页自动填充密码"><a href="#阻止网页自动填充密码" class="headerlink" title="阻止网页自动填充密码"></a>阻止网页自动填充密码</h3><p>在input中加入<code>auto-complete=&quot;new-password&quot;</code></p><h3 id="vue-element-template-跨域处理"><a href="#vue-element-template-跨域处理" class="headerlink" title="vue-element-template:跨域处理"></a>vue-element-template:跨域处理</h3><p>可以直接在devServer下直接添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">      [process.env.VUE_APP_BASE_API]: &#123;</span><br><span class="line">        target: `http://nvxv39qjac6z.ngrok.xiaomiqiu123.top`,//输入后端接口地址</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          [&#x27;^&#x27; + process.env.VUE_APP_BASE_API]: &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>之后在写api时直接填写后端地址即可不用再在开头加入”&#x2F;api”这样的字段拼接<br>在部署到服务器时打包时把跨域代理删除打包</p></blockquote><h3 id="如何将搜索结果关键字高亮显示"><a href="#如何将搜索结果关键字高亮显示" class="headerlink" title="如何将搜索结果关键字高亮显示"></a>如何将搜索结果关键字高亮显示</h3><p>输入框绑定关键词</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;keyWord&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入关键词&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用v-html绑定highlightText方法处理返回的字符串</p><p>使用v-html绑定highlightText方法处理返回的字符串</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;highlightText(text)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>v-thml</code>即是在这个元素下插入渲染标签，相当于是innerHTML</p></blockquote><p>使用正则替换,将搜索关键字替换为由标签＋样式包裹的字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">highlightText</span>(<span class="params">data</span>)&#123;</span><br><span class="line">      <span class="comment">// 将 this.keyWord的值解析成字符串,并根据这个创建正则表达式,</span></span><br><span class="line">      <span class="keyword">let</span> highlightStr = <span class="string">`&lt;span style=&quot;color: #d46200&quot;&gt;<span class="subst">$&#123;<span class="variable language_">this</span>.keyWord&#125;</span>&lt;/span&gt;`</span>;</span><br><span class="line">      <span class="comment">// new 出来一个正则表达式reg</span></span><br><span class="line">      <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="variable language_">this</span>.<span class="property">keyWord</span>);</span><br><span class="line">      <span class="comment">// 返回替换后的新字符串</span></span><br><span class="line">      <span class="keyword">return</span> data.<span class="title function_">replace</span>(reg, highlightStr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>RegExp()为RegExp 对象的构造函数，即构造一个正则表达式，构造函数有两个变量<code>new RegExp(pattern, attributes);</code></p><p><code>pattern</code>可以是字符串也可以是正则表达式；<code>attributes</code> 是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。如果 <code>pattern</code> 是正则表达式，而不是字符串，则必须省略该参数。</p></blockquote><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>当组件拥有 name 属性的时候，就可以在它的模板内递归的调用自己，这在开发树形组件的时候十分有效</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;tree.lable&#125;&#125;<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">example</span> <span class="attr">v-if</span>=<span class="string">&quot;tree.children&quot;</span> <span class="attr">:tree</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;item in tree,children&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>:<span class="string">&quot;example&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            [<span class="string">&#x27;tree&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>&#123;&#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_59079803/article/details/124992321"> 前端面试题八股文汇总（最新）_里见HU的博客-CSDN博客_前端面试八股文</a></p><p><a href="https://blog.csdn.net/zjx147/article/details/124265177">搜索时 实现列表关键字高亮_赵小白学习日记的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">记录一些奇奇怪怪的零碎知识</summary>
    
    
    
    <category term="学习笔记" scheme="https://coffepill.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="vue" scheme="https://coffepill.top/tags/vue/"/>
    
    <category term="css" scheme="https://coffepill.top/tags/css/"/>
    
    <category term="随笔" scheme="https://coffepill.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="js" scheme="https://coffepill.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>CSS实现水平/垂直居中的各种方式整理</title>
    <link href="https://coffepill.top/post/c7dabf43.html"/>
    <id>https://coffepill.top/post/c7dabf43.html</id>
    <published>2022-07-09T18:06:10.000Z</published>
    <updated>2022-07-19T07:12:24.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><p>首先看它的父元素是不是块级元素，如果是，则直接给父元素设置 <code>text-align: center;</code><br>如果不是，则先将其父元素设置为块级元素，再给父元素设置<code>text-align: center;</code> </p><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p><strong>定宽度</strong>：需要谁居中，给其设置 <code>margin: 0 auto;</code> （作用：使盒子自己居中）</p><p> <strong>不定宽度</strong>：默认子元素的宽度和父元素一样，这时需要设置子元素为display: inline-block; 或 display: inline;即将其转换成行内块级&#x2F;行内元素，给父元素设置 <code>text-align: center; </code></p><h3 id="使用定位属性"><a href="#使用定位属性" class="headerlink" title="使用定位属性"></a>使用定位属性</h3><p>首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的<code>left:50%</code>，即让子元素的左上角水平居中；<br><strong>定宽度</strong>：设置绝对子元素的 <code>margin-left: -元素宽度的一半px;</code> 或者设置<code>transform: translateX(-50%);</code></p><p><strong>不定宽度</strong>：利用css3新增属性<code>transform: translateX(-50%);</code></p><p><strong>使用flexbox布局实现</strong></p><blockquote><p>宽度定不定都可以</p></blockquote><p>使用flexbox布局，只需要给待处理的块状元素的父元素添加属性<code>display: flex; justify-content: center;</code> </p><hr><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="单行的行内元素"><a href="#单行的行内元素" class="headerlink" title="单行的行内元素"></a><strong>单行的行内元素</strong></h3><p>只需要设置单行行内元素的”行高等于盒子的高”即可；</p><h3 id="多行的行内元素"><a href="#多行的行内元素" class="headerlink" title="多行的行内元素"></a><strong>多行的行内元素</strong></h3><p>使用给父元素设置<code>display:table-cell;</code>和<code>vertical-align: middle;</code>属即可；</p><h3 id="块级元素-1"><a href="#块级元素-1" class="headerlink" title="块级元素"></a>块级元素</h3><p><strong>方案一：使用定位</strong><br>首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的top: 50%，即让子元素的左上角垂直居中；<br>定高度：设置绝对子元素的 <code>margin-top: -元素高度的一半px;</code> 或者设置<code>transform: translateY(-50%);</code><br>不定高度：利用css3新增属性<code>transform: translateY(-50%);</code></p><p><strong>方案二：使用flexbox布局实现（高度定不定都可以）</strong><br>使用flexbox布局，只需要给待处理的块状元素的父元素添加属性 display: flex; align-items: center;</p><hr><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h3 id="已知高度和宽度的元素"><a href="#已知高度和宽度的元素" class="headerlink" title="已知高度和宽度的元素"></a>已知高度和宽度的元素</h3><p><strong>方案一：</strong>设置父元素为相对定位，给子元素设置绝对定位，<code>top: 0; right: 0; bottom: 0; left: 0; margin: auto;</code></p><p><strong>方案二：</strong>设置父元素为相对定位，给子元素设置绝对定位，</p><p><code>left: 50%; top: 50%; margin-left: --元素宽度的一半px; margin-top: --元素高度的一半px;</code></p><h3 id="未知高度和宽度的元素"><a href="#未知高度和宽度的元素" class="headerlink" title="未知高度和宽度的元素"></a>未知高度和宽度的元素</h3><p><strong>方案一：使用定位属性</strong></p><p>设置父元素为相对定位，给子元素设置绝对定位，<code>left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);</code></p><p><strong>方案二：使用flex布局实现</strong></p><p>设置父元素为flex定位，<code>justify-content: center; align-items: center;</code></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;水平居中&quot;&gt;&lt;a href=&quot;#水平居中&quot; class=&quot;headerlink&quot; title=&quot;水平居中&quot;&gt;&lt;/a&gt;水平居中&lt;/h2&gt;&lt;h3 id=&quot;行内元素&quot;&gt;&lt;a href=&quot;#行内元素&quot; class=&quot;headerlink&quot; title=&quot;行内元素&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="CSS居中" scheme="https://coffepill.top/categories/CSS%E5%B1%85%E4%B8%AD/"/>
    
    
    <category term="CSS" scheme="https://coffepill.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建之路与在配置Bufferfly上踩的坑（2)</title>
    <link href="https://coffepill.top/post/163fe389.html"/>
    <id>https://coffepill.top/post/163fe389.html</id>
    <published>2022-07-08T06:36:41.000Z</published>
    <updated>2022-07-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>原本在搭建的过程顺风顺水，以为很快就可以搭好，结果在配置主题的路上越走越远，这里要说明的是除了butterfly的文档外我大部分网上找的都是对应3.8左右的版本，但是在近年 5 月份的时候他已经更新到了4.0的版本了所以有一些东西的配置跟之前就有所出入了,我所配的版本已经是4.3.0了。我写的逻辑是按页面来可划分的，暂时就是主页与文章页两个模块</code></p><h1 id="Butterfly配置"><a href="#Butterfly配置" class="headerlink" title="Butterfly配置"></a>Butterfly配置</h1><blockquote><p>对于主题的配置都是在主题文件下的<code>_config.yml</code>文件中进行的</p></blockquote><h2 id="首页配置"><a href="#首页配置" class="headerlink" title="首页配置"></a>首页配置</h2><h3 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h3><blockquote><p>如果不要顯示頂部圖，可直接配置 <code>disable_top_img: true</code></p></blockquote><table><thead><tr><th>属性名（解释）</th><th>属性值</th></tr></thead><tbody><tr><td>index_img（首页的顶部图）</td><td>图片地址</td></tr></tbody></table><h3 id="网站副标题"><a href="#网站副标题" class="headerlink" title="网站副标题"></a>网站副标题</h3><p>可设置主页中显示的网站副标题或者喜欢的座右铭。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 主页subtitle</span><br><span class="line">subtitle:</span><br><span class="line">  enable: false</span><br><span class="line">  # Typewriter Effect (打字效果)</span><br><span class="line">  effect: true</span><br><span class="line">  # loop (循环打字)</span><br><span class="line">  loop: true</span><br><span class="line">  # source 调用第三方服务</span><br><span class="line">  # source: false 关闭调用</span><br><span class="line">  # source: 1  调用一言网的一句话（简体） https://hitokoto.cn/</span><br><span class="line">  # source: 2  调用一句网（简体） http://yijuzhan.com/</span><br><span class="line">  # source: 3  调用今日诗词（简体） https://www.jinrishici.com/</span><br><span class="line">  # subtitle 会先显示 source , 再显示 sub 的内容</span><br><span class="line">  source: 3</span><br><span class="line">  # 如果关闭打字效果，subtitle 只会显示 sub 的第一行文字</span><br><span class="line">  sub:</span><br><span class="line">    - 今日事&amp;#44;今日毕</span><br><span class="line">    - Never put off till tomorrow what you can do today。</span><br></pre></td></tr></table></figure><p>修改<code>source</code>即可</p><p><img src="/post/163fe389/1.png"></p><h3 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h3><p>原本的配置中他写的是英文的可以改为中文菜单，这个跟你设置什么语言无关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: / || fas fa-home</span><br><span class="line">  # Archives: /archives/ || fas fa-archive</span><br><span class="line">  目录||fas fa-compass:</span><br><span class="line">    标签: /tags/ || fas fa-tags</span><br><span class="line">    分类: /categories/ || fas fa-folder-open</span><br><span class="line">  # List||fas fa-list:</span><br><span class="line">  #   Music: /music/ || fas fa-music</span><br><span class="line">  #   Movie: /movies/ || fas fa-video</span><br><span class="line">  友链: /link/ || fas fa-link</span><br><span class="line">  关于: /about/ || fas fa-heart</span><br></pre></td></tr></table></figure><p>必须是 &#x2F;xxx&#x2F;，后面||分开，然后写图标名。</p><p>如果不希望显示图标，图标名可不写。</p><p>默认子目录是展开的，如果你想要隐藏，在子目录里添加 hide 。</p><h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><p>【推荐】<code>hexo-generator-index</code>从 2.0.0 开始，已经支持文章置顶功能。你可以直接在文章的front-matter区域里添加<code>sticky: 1</code>属性来把这篇文章置顶。数值越大，置顶的优先级越大。</p><h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  img: /img/avatar.png</span><br><span class="line">  effect: true # 头像会一直转圈</span><br></pre></td></tr></table></figure><h3 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Favicon（網站圖標）</span><br><span class="line">favicon: /img/bitbug_favicon.ico</span><br></pre></td></tr></table></figure><h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><h4 id="最新评论"><a href="#最新评论" class="headerlink" title="最新评论"></a>最新评论</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">newest_comments:</span><br><span class="line">  enable: true</span><br><span class="line">  sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br><span class="line">  limit: 6</span><br><span class="line">  storage: 10 # unit: mins, save data to localStorage</span><br><span class="line">  avatar: true</span><br></pre></td></tr></table></figure><blockquote><p>侧边栏里还有对卡片的属性的配置，可以在配置文件里搜索“aside”去找到</p><p>如：修改自己名称下的个性签名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">card_author:</span><br><span class="line">    enable: true</span><br><span class="line">    description: 好好摸鱼</span><br><span class="line">    button:</span><br><span class="line">      enable: true</span><br><span class="line">      icon: fab fa-github</span><br><span class="line">      text: Follow Me</span><br><span class="line">      link: https://github.com/NPCa</span><br></pre></td></tr></table></figure><p><code>card_author</code>就是作者信息的卡片，<code>description</code>属性就可以填写自己的个性签名</p></blockquote><h3 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h3><p>我安的是本地搜索的插件</p><blockquote><p>记得运行<code>hexo clean</code></p></blockquote><p>1.需要先安装插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>2.修改配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  preload: false</span><br><span class="line">  CDN:</span><br></pre></td></tr></table></figure><h3 id="页面美化"><a href="#页面美化" class="headerlink" title="页面美化"></a>页面美化</h3><h4 id="背景彩带"><a href="#背景彩带" class="headerlink" title="背景彩带"></a>背景彩带</h4><p>静态彩带：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">canvas_ribbon:</span><br><span class="line">  enable: true</span><br><span class="line">  size: 150</span><br><span class="line">  alpha: 0.6</span><br><span class="line">  zIndex: -1</span><br><span class="line">  click_to_change: true  #设置是否每次点击都更换綵带</span><br><span class="line">  mobile: false # false 手机端不显示 true 手机端显示</span><br></pre></td></tr></table></figure><p>动态彩带：彩带自己会飘动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas_fluttering_ribbon:</span><br><span class="line">  enable: true</span><br><span class="line">  mobile: false # false 手机端不显示 true 手机端显示</span><br></pre></td></tr></table></figure><h3 id="Footer设置"><a href="#Footer设置" class="headerlink" title="Footer设置"></a>Footer设置</h3><h4 id="博客年份"><a href="#博客年份" class="headerlink" title="博客年份"></a>博客年份</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  owner:</span><br><span class="line">    enable: true</span><br><span class="line">    since: 2018</span><br></pre></td></tr></table></figure><h4 id="页脚自定义文本"><a href="#页脚自定义文本" class="headerlink" title="页脚自定义文本"></a>页脚自定义文本</h4><p><code>custom_text</code>是一个给你用来在页脚自定义文本的选项。通常你可以在这里写声明文本等。支持 HTML。</p><p>修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">custom_text: Hi, welcome to my &lt;a href=&quot;https://butterfly.js.org/&quot;&gt;blog&lt;/a&gt;!</span><br></pre></td></tr></table></figure><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>4.0版本之后图片懒加载的属性有一些变化，作者把懒加载的图片默认设置为透明，如果要自定义懒加载图片就在placeholder属性填写懒加载的图片路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Lazyload (圖片懶加載)</span><br><span class="line"># https://github.com/verlok/vanilla-lazyload</span><br><span class="line">lazyload:</span><br><span class="line">  enable: true</span><br><span class="line">  field: site # site/post</span><br><span class="line">  placeholder: /img/loading.gif</span><br><span class="line">  blur: true</span><br></pre></td></tr></table></figure><h3 id="页面加载动画"><a href="#页面加载动画" class="headerlink" title="页面加载动画"></a>页面加载动画</h3><p>当进入网页时，因为加载速度的问题，可能会导致<code>top_img</code>图片出现断层显示，或者网页加载不全而出现等待时间，开启<code>preloader</code>后，会显示加载动画，等页面加载完，加载动画会消失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 加载动画 Loading Animation</span><br><span class="line">preloader: true</span><br></pre></td></tr></table></figure><hr><h2 id="文章页"><a href="#文章页" class="headerlink" title="文章页"></a>文章页</h2><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。</p><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标籤，多标签采用数组形式，如tags: [css,js]</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr></tbody></table><h3 id="文章置顶-1"><a href="#文章置顶-1" class="headerlink" title="文章置顶"></a>文章置顶</h3><p>【推荐】<code>hexo-generator-index</code>从 2.0.0 开始，已经支持文章置顶功能。你可以直接在文章的front-matter区域里添加<code>sticky: 1</code>属性来把这篇文章置顶。数值越大，置顶的优先级越大。</p><h3 id="评论系统valine-x2F-twikoo"><a href="#评论系统valine-x2F-twikoo" class="headerlink" title="评论系统valine&#x2F;twikoo"></a>评论系统valine&#x2F;twikoo</h3><p><code>valine</code>的配置比较简单按文档走就可以</p><p>遵循 <a href="https://github.com/xCss/Valine">Valine</a>的指示去配置你的 LeanCloud 应用。以及查看相应的配置説明。</p><p>然后修改 主题配置文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  appId: # leancloud application app id</span><br><span class="line">  appKey: # leancloud application app key</span><br><span class="line">  avatar: monsterid # gravatar style https://valine.js.org/#/avatar</span><br><span class="line">  serverURLs: # This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span><br><span class="line">  bg: # valine background</span><br><span class="line">  visitor: false</span><br><span class="line">  option:</span><br></pre></td></tr></table></figure><blockquote><p>twikoo的配置可以参考这个博客配置<a href="https://imlql.cn/post/bb283ed3.html">Hexo搭建博客-butterfly主题新版教程 | 风祈的时光录 (imlql.cn)</a></p></blockquote><hr><blockquote><p>以上部分是我个人觉得大家都会去配置而系统默认没有配置的地方，有些需求系统默认是打开的我就没写上去了</p></blockquote><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></p><p><a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安裝文檔(四) 主題配置-2 | Butterfly</a></p><p><a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安裝文檔(四) 主題配置-2 | Butterfly</a></p><p><a href="https://imlql.cn/post/bb283ed3">Hexo搭建博客-butterfly主题新版教程 | 风祈的时光录 (imlql.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;原本在搭建的过程顺风顺水，以为很快就可以搭好，结果在配置主题的路上越走越远，这里要说明的是除了butterfly的文档外我大部分网上找的都是对应3.8左右的版本，但是在近年 5 月份的时候他已经更新到了4.0的版本了所以有一些东西的配置跟之前就有所出入了,我所配</summary>
      
    
    
    
    <category term="博客搭建与主题配置" scheme="https://coffepill.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="Buffterfly4.3.0" scheme="https://coffepill.top/tags/Buffterfly4-3-0/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建之路与在配置Bufferfly上踩的坑（1）</title>
    <link href="https://coffepill.top/post/c9180b2c.html"/>
    <id>https://coffepill.top/post/c9180b2c.html</id>
    <published>2022-07-07T08:41:36.000Z</published>
    <updated>2022-07-11T07:47:10.430Z</updated>
    
    <content type="html"><![CDATA[<p><strong><code>这几天趁着没事，在导师公司摸鱼的时间，学着搭了这个个人博客。最开始我是跟着B站的来着一位叫做码游菌的一篇<a herf="https://www.bilibili.com/read/cv12633102" alt="2021最全hexo搭建博客+matery美化+使用（保姆级教程）">文章</a>搭建的。主题则是选择了<a herf="">Butterfly</a>,这里主要是想整理记录一下自己在搭建时与在对主题进行配置运用时遇到的坑</code></strong></p><h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>这里主要需要准备先安装好一些下载工具</p><ol><li><p>安装<a href="https://nodejs.org/en/">node.js</a></p></li><li><p>安装<a href="https://git-scm.com/download/win">git</a></p></li><li><p>命令行安装npm的淘宝镜像 cnpm(因为有npm指令下载安装有时候会很慢或者报错的问题)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry==https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>命令行安装hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="搭建github仓库"><a href="#搭建github仓库" class="headerlink" title="搭建github仓库"></a>搭建github仓库</h3><h4 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h4><ul><li>新建一个名为你的用户名.github.io的仓库</li><li>比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/">http://test.github.io</a> 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</li></ul><blockquote><p>注意：</p><ul><li>仓库名字必须是：username.github.io，其中username是你的用户名；</li><li>github服务器在国外有时候会打不开，如果打不开可以选择下个stream++或者挂个VPN</li><li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久； </li><li>如果之前已经有创建过同名仓库，只能创建一个新的github账号或者是删除这个仓库重新建立</li></ul></blockquote><h5 id="删除仓库的方法"><a href="#删除仓库的方法" class="headerlink" title="删除仓库的方法:"></a>删除仓库的方法:</h5><p>  ​1.点击进入仓库，点击setting</p><p>  <img src="/post/c9180b2c/1.png" alt="点击setting"></p><p>  ​2.之后拉到页面底部点击  Delete this repository  按钮</p><p>  <img src="/post/c9180b2c/2.png"></p><p>  ​3.然后再弹出框里写入对应的仓库名，点击下面的按钮即可删除成功</p><p>  <img src="/post/c9180b2c/3.png"></p><blockquote><p>这一步其实还有包括配置SSH免密以及绑定域名的操作，这两步是可选操作属于优化项</p></blockquote><hr><h3 id="使用hexo搭建博客"><a href="#使用hexo搭建博客" class="headerlink" title="使用hexo搭建博客"></a>使用hexo搭建博客</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>第一步：选择或者创建一个用来存放代码的文件夹，比如我的是D:\coffeeSleep</p><p>第二步：在D:\coffeeSleep下打开Git Bash Here,输入一下命令初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>第三步：执行一下两条命令，hexo就会在public文件夹中生成对应的html文件，这些就是要提交到git仓库的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g #生成</span><br><span class="line">hexo s #启动服务</span><br></pre></td></tr></table></figure><p>第四步：hexo s 是开启本地预览服务，打开浏览器访问<a href="http://localhost:4000/"> http://localhost:4000 </a>即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章<a href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">https://www.runoob.com/w3cnote/windows-finds-port-usage.html</a></p><blockquote><p>这样初始化就算完成了</p></blockquote><h4 id="对个人信息进行配置"><a href="#对个人信息进行配置" class="headerlink" title="对个人信息进行配置"></a>对个人信息进行配置</h4><p>同样是在根目录下的_config.yml中配置</p><p><img src="/post/c9180b2c/5.png"></p><p>其他配置可以去看<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><h4 id="将博客部署到github个人主页上"><a href="#将博客部署到github个人主页上" class="headerlink" title="将博客部署到github个人主页上"></a>将博客部署到github个人主页上</h4><p>第一步：在D:\coffeeSleep下安装 hexo-deployer-git 插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><blockquote><p>一定要安装，没安装无法上传对应代码</p></blockquote><p>第二步：在项目根目录下的_confing.yml文件中,找到如下图的deploy属性配置git上传地址</p><p><img src="/post/c9180b2c/4.png"></p><blockquote><p>repository填写仓库地址，如果有配置SSH免密就用SSH地址就可以，没有配置那在上传的时候就会弹出需要git授权，按要求授权就行</p></blockquote><p>第三步：在项目根目录下运行Git Bash输入命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><blockquote><p>hexo d指令上传代码至github仓库时可能会报错， <code>Failed to connect to github.com port 443 after 2029 ms</code>，这个可能就是请求因为连接github超时，需要挂个加速器或者科学上网才可以用</p></blockquote><p><strong>推送成功后即可通过访问https:&#x2F;&#x2F;用户名.github.io访问自己的博客</strong></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>hexo原生的主题很不好看，正常我们都会去更换主题来重新渲染</p><p>首先，我们要找一个好看的觉得适合自己的主题，</p><p>你也可以在hexo的官网寻找自己想要的主题<a href="https://hexo.io/themes/">Themes | Hexo</a></p><p>这个博客现用的的是Butterfly</p><p><a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p><p>在根目录下用命令行克隆，之后就会有个themes的文件夹里面就会有这个butterfly主题的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>之后，在根目录下的_confing.yml文件中找到themes属性加入对应名称如：</p><p><img src="/post/c9180b2c/7.png"></p><p>然后依次执行hexo g,hexo d即可，如果有报错就先执行hexo clean清除一下在执行hexo g即可</p><hr><p><strong>未完待续。。。</strong></p><hr><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a href="https://www.bilibili.com/read/cv12633102">2021最全hexo搭建博客+matery美化+使用（保姆级教程） - 哔哩哔哩 (bilibili.com)</a></p>]]></content>
    
    
    <summary type="html">hexo博客搭建</summary>
    
    
    
    <category term="博客搭建与主题配置" scheme="https://coffepill.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="hexo" scheme="https://coffepill.top/tags/hexo/"/>
    
    <category term="git" scheme="https://coffepill.top/tags/git/"/>
    
  </entry>
  
</feed>
